#!/usr/bin/env python
import sys
import argparse
from string import strip
import operator

__CITATION__ = '''#       ** If you use this software for a published work, please cite: **
#  
# Jaime Huerta-Cepas, Joaquin Dopazo and Toni Gabaldon. ETE: a python Environment
# for Tree Exploration. BMC Bioinformatics 2010, 11:24. doi: 10.1186/1471-2105-11-24.'''

FACES = []
LOG_LEVEL = 2

class Logger(object):
    def __init__(self, buff):
        self.out = buff
    
    def error(self, *args):
        if LOG_LEVEL >=1:
            print >>self.out, "ERROR - ", ' '.join(map(str, args))
            
    def warn(self, *args):
        if LOG_LEVEL >=2:
            print >>self.out, "WARN  - ", ' '.join(map(str, args))
            
    def info(self, *args):
        if LOG_LEVEL >=3:
            print >>self.out, "INFO  - ", ' '.join(map(str, args))
        
    def debug(self, *args):
        if LOG_LEVEL >=4:
            print >>self.out, "DEBUG - ", ' '.join(map(str, args))
    
log = Logger(sys.stderr)

paired_colors = ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99',
                 '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a',
                 '#ffff99', '#b15928']

COLOR_RANKS = { "superclass": "#a6cee3", "class": "#a6cee3", "subclass": "#a6cee3", "infraclass": "#a6cee3",
                "superfamily": "#1f78b4", "family": "#1f78b4", "subfamily": "#1f78b4",
                "superkingdom": "#b2df8a", "kingdom": "#b2df8a", "subkingdom": "#b2df8a", "superorder": "#33a02c",
                "order": "#33a02c", "suborder": "#33a02c", "infraorder": "#33a02c", "parvorder": "#33a02c",
                "superphylum": "#fdbf6f", "phylum": "#fdbf6f",  "subphylum": "#fdbf6f"}

#    "species group": "",
#    "species subgroup": "",
#    "species": "",
#    "subspecies": "",
#    "genus": "",
#    "subgenus": "",
#    "no rank": "",
#    "forma": "",
#    "tribe": "",
#    "subtribe": "",
#    "varietas"
           
def itertrees(trees, treefile):
    if trees:
        for nw in trees:
            yield nw
    if treefile:
        for line in open(treefile):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            else:
                yield line

def node_matcher(node, filters):
    if not filters:
        return True
    
    for f in filters:        
        node_v = getattr(node, f[0], None)
        if node_v:
            try:
                node_v = type(f[2])(node_v)
            except ValueError:
                pass
            if OPFUNC[f[1]](node_v, f[2]):
                return True
            # else:
            #     print f, node_v, type(node_v)
    return False
            
def _re(q, exp):
    if re.search(exp, q):
        return True
    return False

POSNAMES = {
    "b-right":"branch-right",
    "b-top":"branch-top",
    "b-bottom":"branch-bottom",
    "float":"float",
    "float-behind":"float-behind",
    "aligned":"aligned",
}

OPFUNC = {
    "<":operator.lt,
    ">":operator.gt,
    "=":operator.eq,
    "==":operator.eq,
    "!=":operator.ne,
    ">=":operator.ge,
    "<-":operator.le,
    "~=":_re,
}
    
def parse_faces(face_args):    
    faces = []
    for fargs in face_args:
        face = {"filters":[],
                "ftype":"text",
                "value":None,
                "pos": "branch-right",
                "color": None,
                "bgcolor": None,
                "size": 12,
                "fstyle":None, # review this name
                "column":None,
                "format":None,
                "nodetype":"leaf",
                "opacity":None,
        }

        for clause in map(strip,fargs.split(',')):
            key, value = map(strip, clause.split(":"))
            key = key.lower()
            if key == "if":
                m = re.search("([^=><~!]+)(>=|<=|!=|~=|=|>|<)([^=><~!]+)", value)
                if not m:
                    raise ValueError("Invalid syntaxis in 'if' clause: %s" %clause)
                else:
                    target, op, value = map(strip, m.groups())
                    target = target.lstrip('@')
                    try:
                        value = float(value)                        
                    except ValueError:
                        pass
                        
                    face["filters"].append([target, op, value])                    
            elif key == "pos":
                try:
                    face["pos"] = POSNAMES[value]
                except KeyError:
                    raise ValueError("Invalid face position: %s" %clause)
            elif key == "nodetype":
                value = value.lower()
                if value != "any" and value != "internal" and value != "leaf":
                    raise ValueError("Invalid nodetype: %s" %clause)
                face["nodetype"] = value
            elif key == "size":
                face["size"] = int(value)
            elif key == "opacity":
                face["opacity"] = float(value)
            elif key == "column":
                face["column"] = int(value)
            elif key == "color":
                if value.endswith("()"):
                    func_name = value[0:-2]
                face[key] = value
            elif key == "fstyle":
                if value != 'italic' and value != 'bold':
                    raise ValueError("valid style formats are: italic, bold [%s]" %clause)
                face[key] = value                
            elif key == "format":
                if "%" not in value:
                    print value
                    raise ValueError("format attribute should contain one format char: ie. %%s [%s]" %clause)
                face[key] = value.strip("\"")                
            elif key in face:
                face[key] = value
            else:
                raise ValueError("unknown keyword in face options: %s" %clause )
        faces.append(face)
    return faces

def as_str(v):
    if isinstance(v, float):
        return '%0.2f' %v
    else:
        return str(v)

def shorten_str(string, l):
    if len(string) > l:
        return "%s(...)" % string[:l-5]
    else:
        return string  
            
def euc_dist(v1, v2):
    if type(v1) != set: v1 = set(v1)
    if type(v2) != set: v2 = set(v2)
   
    return len(v1 ^ v2) / float(len(v1 | v2))

def euc_dist_unrooted(v1, v2):
    a = (euc_dist(v1[0], v2[0]) + euc_dist(v1[1], v2[1])) / 2.0
    b = (euc_dist(v1[1], v2[0]) + euc_dist(v1[0], v2[1])) / 2.0
    return min(a, b)

class ArgError(ValueError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        # return repr(self.value)
        return self.value
    pass

# MAIN PROGRAMS
def ete_generate(args):
    import random
    from ete_dev import Tree
    
    for n in xrange(args.number):
        t = Tree()
        t.populate(args.size, random_branches=args.random_branches)
        dump(t)

def ete_mod(args):
    from ete_dev import Tree
    
    for nw in args.src_tree_iterator:
        t = Tree(nw)
        mod_tree(t, args)
        dump(t)

def mod_tree(t, args):
    if args.ladderize and args.sort:
        raise ValueError("--sort-branches and --ladderize options are mutually exclusive")

    if args.prune:
        t.prune(args.prune, preserve_branch_length=args.prune_preserve_lengths)    
    
    if args.outgroup and args.unroot:
        raise ValueError("--ourgroup and --unroot options are mutually exclusive")
    elif args.outgroup:
        if len(args.outgroup) > 1:
            outgroup = t.get_common_ancestor(args.outgroup)
        else:
            outgroup = t & args.outgroup[0]
        t.set_outgroup(outgroup)
    elif args.unroot:
        t.unroot()

    if args.resolve_polytomies:
        t.resolve_polytomy()
        
    if args.ladderize:
        t.ladderize()
    if args.sort:
        t.sort_descendants()

    if args.ultrametric:
        t.convert_to_ultrametric()
    
    # remove
    # ncbi_root
            
def ete_split(args):
    # bydups, bydist, name, find clsuters
    log.error('Oops, this tool is not implemented yet')

def ete_expand(args):
    # polytomies 
    log.error('Oops, this tool is not implemented yet')

def ete_extract(args):
    from ete_dev import PhyloTree, Tree
    
    for nw in args.src_tree_iterator:        
        dups = []
        orth = []        
        if args.orthologs or args.duplications:
            t = PhyloTree(nw)
            events = t.get_descendant_evol_events()

            for e in events:
                if e.etype == "D" and args.orthologs:
                    print "paralogy", ','.join(e.in_seqs), ','.join(e.out_seqs)
                if e.etype == "S" and args.orthologs:
                    print "orthology", ','.join(e.in_seqs), ','.join(e.out_seqs)

        if args.edges:
            t = Tree(nw)
            for edge in t.iter_edges():
                print '\t'.join([','.join([node.name for node in branch]) for branch in edge])

                
    # dups, orthologs, partitions, edges, dist_matrix, ancestor, 
    # target species/sequence
    
def ete_convert(args):
    # between newick formats, orthoxml, phyloxml
    log.error('Oops, this tool is not implemented yet')

def ete_maptrees(args):
    log.error('Oops, this tool is not implemented yet')

def ete_reconcile(args):
    log.error('Oops, this tool is not implemented yet')

def ete_consense(args):
    # all observed splits    
    for nw in args.src_tree_iterator:
        pass
    log.error('Oops, this tool is not implemented yet')
    
def ete_fetch(args):
    log.error('Oops, this tool is not implemented yet')

def ete_codeml(args):
    log.error('Oops, this tool is not implemented yet')

def ete_ncbiquery(args):
    # add lineage profiles/stats    
    import re
    from ete_dev import PhyloTree, NCBITaxa

    if not args.taxonomy and not args.info:
        args.taxonomy = True
    
    ncbi = NCBITaxa()

    all_taxids = {}
    all_names = set()
    queries = []    
    for n in args.search:
        queries.append(n)
        try:
            all_taxids[int(n)] = None
        except ValueError:
            all_names.add(n.strip())
            
    # translate names
    name2tax = ncbi.get_name_translator(all_names)
    all_taxids.update([(v, None) for v in name2tax.values()])

    not_found_names = all_names - set(name2tax.keys())
    if args.fuzzy and not_found_names:
        log.warn("%s unknown names", len(not_found_names))
        for name in not_found_names:
            # enable extension loading
            tax, realname, sim = ncbi.get_fuzzy_name_translation(name, args.fuzzy)
            if tax:
                all_taxids[tax] = None
                name2tax[name] = tax
                name2realname[name] = realname
                name2score[name] = "Fuzzy:%0.2f" %sim
                                    
    if args.taxonomy:
        log.info("Dumping NCBI taxonomy of %d taxa..." %(len(all_taxids)))
        t = ncbi.get_topology(all_taxids.keys(),
                              intermediate_nodes=args.full_lineage,
                              rank_limit=args.rank_limit,
                              collapse_subspecies=args.collapse_subspecies)
        
        id2name = ncbi.get_taxid_translator([n.name for n in t.traverse()])
        for n in t.traverse():
            n.add_features(taxid=n.name)
            n.add_features(sci_name=str(id2name.get(int(n.name), "?")))
            n.name = "%s - %s" %(id2name.get(int(n.name), n.name), n.name)
            lineage = ncbi.get_sp_lineage(n.taxid)
            n.add_features(named_lineage = '|'.join(ncbi.translate_to_names(lineage)))
        dump(t, features=["taxid", "name", "rank", "bgcolor", "sci_name",
                          "collapse_subspecies", "named_lineage"])
    elif args.info:
        print '# ' + '\t'.join(["Taxid", "Sci.Name", "Rank", "Named Lineage", "Taxid Lineage"])
        translator = ncbi.get_taxid_translator(all_taxids)
        ranks = ncbi.get_ranks(all_taxids) 
        for taxid, name in translator.iteritems():
            lineage = ncbi.get_sp_lineage(taxid)            
            named_lineage = ','.join(ncbi.translate_to_names(lineage))
            lineage_string = ','.join(map(str, lineage))
            print '\t'.join([str(taxid), name, ranks.get(taxid, ''), named_lineage, lineage_string])
            
def ete_annotate(args):
    from ete_dev import Tree, PhyloTree
        
    features = set()    
    for nw in args.src_tree_iterator:
        if args.ncbi:
            tree = PhyloTree(nw)
            features.update(["taxid", "name", "rank", "bgcolor", "sci_name",
                             "collapse_subspecies", "named_lineage", "lineage"])            
            tree.annotate_ncbi_taxa(args.taxid_attr)
        else:
            tree = Tree(nw)
        
        type2cast = {"str":str, "int":int, "float":float, "set":set, "list":list}

        for annotation in args.feature:
            aname, asource, amultiple, acast = None, None, False, str
            for field in annotation:
                try:
                    key, value = map(strip, field.split(":"))
                except Exception:
                    raise ValueError("Invalid feature option [%s]" %field )
                
                if key == "name":
                    aname = value
                elif key == "source":
                    asource = value
                elif key == "multiple":
                    #append
                    amultiple = value
                elif key == "type":
                    try:
                        acast = type2cast[value]
                    except KeyError:
                        raise ValueError("Invalid feature type [%s]" %field)
                else:
                    raise ValueError("Unknown feature option [%s]" %field)
                
            if not aname and not asource:
                ValueError('name and source are required when annotating a new feature [%s]'
                           % annotation)
                    
            features.add(aname)
            for line in open(asource, 'rU'):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                nodenames, attr_value = map(strip, line.split('\t'))
                nodenames = map(strip, nodenames.split(','))
                relaxed_grouping = True
                if nodenames[0].startswith('!'):
                    relaxed_grouping = False
                    nodenames[0] = nodenames[0][1:]
                    
                if len(nodenames) > 1:
                    target_node = tree.get_common_ancestor(nodenames)
                    if not relaxed_grouping:
                        pass
                        # do something
                else:
                    target_node = tree & nodenames[0] 

                if hasattr(target_node, aname):
                    log.warning('Overwriting annotation for node" [%s]"' %nodenames)
                else:
                    target_node.add_feature(aname, acast(attr_value))
            
        dump(tree, features=features)

def ete_compare(args):
    from ete_dev import Tree
    from ete_dev.utils import print_table
    
    def iter_differences(set1, set2, unrooted=False):
        for s1 in set1:
            pairs = []
            for r1 in set2:
                if unrooted:
                    d = euc_dist_unrooted(s1, r1)
                else:
                    d = euc_dist(s1, r1)
                if d < 1:
                    pairs.append((d,r1))
            yield s1, pairs

    
    col_sizes = [25, 25] + [8] * 8
            
    print_table([['source', 'ref', 'eff.size', 'nRF',
                 'RF', 'maxRF', "%src_branches",
                  "%ref_branches", "subtrees", "treekoD" ],
                 ["=========================="] * 10],
                fix_col_width=col_sizes, wrap_style="cut")
    

    for stree_name in args.src_tree_iterator:
        stree = Tree(stree_name)
        for rtree_name in args.ref_trees:
            rtree = Tree(rtree_name)
            r = stree.compare(rtree, 
                              ref_tree_attr=args.ref_tree_attr,
                              source_tree_attr=args.src_tree_attr,
                              min_support_ref=args.min_support_ref,
                              min_support_source = args.min_support_src,
                              unrooted=args.unrooted,
                              has_duplications=False)


            print_table([map(as_str, [shorten_str(stree_name,25),
                                      shorten_str(rtree_name,25),
                                      r['effective_tree_size'],
                                      r['norm_rf'], 
                                      r['rf'], r['max_rf'],
                                      r["source_edges_in_ref"],
                                      r["ref_edges_in_source"],
                                      r['source_subtrees'],
                                      r['treeko_dist']])],
                        fix_col_width = col_sizes, wrap_style='cut')

            if args.differences:
                # EXPERIMENTAL
                from pprint import pprint
                import itertools

                mismatches_src = r['source_edges'] - r['ref_edges']
                mismatches_ref = r['ref_edges'] - r['source_edges']
                for part, pairs in iter_differences(mismatches_src,
                                                    mismatches_ref,
                                                    unrooted=args.unrooted):
                    print part
                    for d, r in sorted(pairs):
                        print "  ", d, r
    print
                
def ete_view(args):
    import random
    import re
    import colorsys
    from collections import defaultdict
    from ete_dev import (Tree, PhyloTree, TextFace, RectFace, faces, TreeStyle,
                         add_face_to_node, random_color)

    def gradient_color(value, max_value, saturation=0.5, hue=0.1):
        DEFAULT_COLOR_SATURATION = 0.3
        BASE_LIGHTNESS = 0.7

        def rgb2hex(rgb):
            return '#%02x%02x%02x' % rgb
        def hls2hex(h, l, s):
            return rgb2hex( tuple(map(lambda x: int(x*255), colorsys.hls_to_rgb(h, l, s))))

        lightness = 1 - (value * BASE_LIGHTNESS) / max_value
        return hls2hex(hue, lightness, DEFAULT_COLOR_SATURATION)

    
    global FACES
    
    if args.face:
        FACES = parse_faces(args.face)
    else:
        FACES = []

    # VISUALIZATION
    ts = TreeStyle()
    ts.mode = args.mode
    ts.show_leaf_name = True
    ts.tree_width = args.tree_width
    ts.legend_position = 3
    
    for f in FACES:
        if f["value"] == "@name":
            ts.show_leaf_name = False
            break

    if args.as_ncbi:
        ts.show_leaf_name = False
        FACES.extend(parse_faces(
            ['value:@sci_name, size:10, fstyle:italic',
             'value:@taxid, color:grey, size:6, format:" - %s"',
             'value:@sci_name, color:steelblue, size:7, pos:b-top, nodetype:internal',
             'value:@rank, color:indianred, size:6, pos:b-bottom, nodetype:internal',
         ]))


    if args.alg:
        FACES.extend(parse_faces(
            ['value:@sequence, size:10, pos:aligned, ftype:%s' %args.alg_type]
         ))

    if args.heatmap:
        FACES.extend(parse_faces(
            ['value:@name, size:10, pos:aligned, ftype:heatmap']
         ))
        
    if args.bubbles:
        for bubble in args.bubbles:
            FACES.extend(parse_faces(
                ['value:@%s, pos:float, ftype:bubble, opacity:0.4' %bubble,
             ]))
                        
    ts.branch_vertical_margin = args.branch_separation
    if args.show_support:
        ts.show_branch_support = True
    if args.show_branch_length:
        ts.show_branch_length = True
    if args.force_topology:
        ts.force_topology = True
    ts.layout_fn = lambda x: None
        
    for tindex, tfile in enumerate(args.src_tree_iterator):

        # load Tree
        if args.raxml:
            nw = re.sub(":(\d+\.\d+)\[(\d+)\]", ":\\1[&&NHX:support=\\2]", open(tfile).read())
            t = PhyloTree(nw)
        else:
            t = PhyloTree(tfile)

        # load Alg
        if args.alg:
            t.link_to_alignment(args.alg, alg_format=args.alg_format)

        # load matrix data heatmap
        if args.heatmap:            
            heatmap_data = {}
            heatmap_header = []
            heatmap_max_value, heatmap_min_value = None, None
            for line in open(args.heatmap):
                if not heatmap_header and line.startswith('#NAMES'):
                    heatmap_header = map(strip, line.split("\t")[1:])
                elif line.startswith('#') or not line.strip():
                    pass
                else:
                    fields = line.split('\t')
                    name = fields[0].strip()

                    values = map(lambda x: float(x) if x else None, fields[1:])

                    maxv = max(values)
                    minv = min(values)
                    if heatmap_max_value is None or maxv > heatmap_max_value:
                        heatmap_max_value = maxv
                    if heatmap_min_value is None or minv < heatmap_min_value:
                        heatmap_min_value = minv                        
                    heatmap_data[name] = values
                    
            heatmap_header_drawn = False
            heatmap_center_value = heatmap_min_value if args.heatmap_center_value is None else args.heatmap_center_value
            heatmap_color_center = "white"
            heatmap_color_up = args.heatmap_color_up
            heatmap_color_down = args.heatmap_color_down
            heatmap_color_missing = "black"
            heatmap_height = args.heatmap_height
            heatmap_width = args.heatmap_width
            heatmap_header_size = 9
                    
            if heatmap_center_value <= heatmap_min_value:
                heatmap_ref_max = abs(heatmap_center_value - heatmap_min_value) + abs(heatmap_center_value - heatmap_max_value)
            else:
                heatmap_ref_max = max(abs(heatmap_center_value - heatmap_min_value),
                                      abs(heatmap_center_value - heatmap_max_value))
                    
                    
        # scale the tree
        if not args.height: 
            args.height = None
        if not args.width: 
            args.width = None

        if args.text_mode:
            print t.get_ascii(show_internal=args.show_internal_names,
                              attributes=args.show_attributes)
        else:    
            f2color = {}
            f2last_seed = {}
            for node in t.traverse():
                node.img_style['size'] = 0                
                if len(node.children) == 1:
                    node.img_style['size'] = 2                
                    node.img_style['shape'] = "square"
                    node.img_style['fgcolor'] = "steelblue"

                ftype_pos = defaultdict(int)
                
                for findex, f in enumerate(FACES):
                    if (f['nodetype'] == 'any' or 
                        (f['nodetype'] == 'leaf' and node.is_leaf()) or
                        (f['nodetype'] == 'internal' and not node.is_leaf())):
                        

                        # if node passes face filters
                        if node_matcher(node, f["filters"]):
                            if f["value"].startswith("@"):
                                fvalue = getattr(node, f["value"][1:], None)
                            else:
                                fvalue = f["value"]

                            # if node's attribute has content, generate face
                            if fvalue is not None:
                                fsize = f["size"]
                                fbgcolor = f["bgcolor"]
                                fcolor = f['color']
                                
                                if fcolor:
                                    # Parse color options
                                    auto_m = re.search("auto\(([^)]*)\)", fcolor)
                                    if auto_m:
                                        target_attr = auto_m.groups()[0].strip()
                                        if not target_attr :
                                            color_keyattr = f["value"]
                                        else:
                                            color_keyattr = target_attr

                                        color_keyattr = color_keyattr.lstrip('@')
                                        color_bin = getattr(node, color_keyattr, None)

                                        last_seed = f2last_seed.setdefault(color_keyattr, random.random())

                                        seed = last_seed + 0.10 + random.uniform(0.1, 0.2)
                                        f2last_seed[color_keyattr] = seed

                                        fcolor = f2color.setdefault(color_bin, random_color(h=seed))

                                if fbgcolor:
                                    # Parse color options
                                    auto_m = re.search("auto\(([^)]*)\)", fbgcolor)
                                    if auto_m:
                                        target_attr = auto_m.groups()[0].strip()
                                        if not target_attr :
                                            color_keyattr = f["value"]
                                        else:
                                            color_keyattr = target_attr

                                        color_keyattr = color_keyattr.lstrip('@')
                                        color_bin = getattr(node, color_keyattr, None)

                                        last_seed = f2last_seed.setdefault(color_keyattr, random.random())

                                        seed = last_seed + 0.10 + random.uniform(0.1, 0.2)
                                        f2last_seed[color_keyattr] = seed

                                        fbgcolor = f2color.setdefault(color_bin, random_color(h=seed))

                                if f["ftype"] == "text":
                                    if f.get("format", None):
                                        fvalue = f["format"] % fvalue
                                    
                                    F = TextFace(fvalue,
                                                 fsize = fsize,
                                                 fgcolor = fcolor or "black",
                                                 fstyle = f.get('fstyle', None))

                                elif f["ftype"] == "fullseq":
                                    F = faces.SeqMotifFace(seq=fvalue, seq_format="seq",
                                                           seqtail_format="seq",
                                                           height=fsize)
                                elif f["ftype"] == "compactseq":
                                    F = faces.SeqMotifFace(seq=fvalue, seq_format="compactseq",
                                                           seqtail_format="compactseq",
                                                           height=fsize)
                                elif f["ftype"] == "blockseq":
                                    F = faces.SeqMotifFace(seq=fvalue, seq_format="blockseq",
                                                       seqtail_format="blockseq",
                                                           height=fsize,
                                                           fgcolor=fcolor or "slategrey",
                                                           bgcolor=fbgcolor or "slategrey",
                                                           scale_factor = 1.0)
                                    fbgcolor = None
                                elif f["ftype"] == "bubble":
                                    try:
                                        v = float(fvalue)
                                    except ValueError:
                                        rad = fsize
                                    else:
                                        rad = fsize * v
                                    F = faces.CircleFace(radius=rad, style="sphere",
                                                         color=fcolor or "steelblue")

                                elif f["ftype"] == "heatmap":
                                    if not f['column']:
                                        col = ftype_pos[f["pos"]]
                                    else:
                                        col = f["column"]

                                    # Add header
                                    if not heatmap_header_drawn:
                                        for i, hname in enumerate(heatmap_header):
                                            nameF = TextFace(hname, fsize=heatmap_header_size)
                                            nameF.rotation = -90
                                            ts.aligned_header.add_face(nameF, column=col+i)
                                            
                                        # add legend
                                        color1 = gradient_color(abs(heatmap_center_value - heatmap_max_value), heatmap_ref_max, hue=heatmap_color_up)
                                        color2= gradient_color(abs(heatmap_center_value - heatmap_min_value), heatmap_ref_max, hue=heatmap_color_down)

                                        ts.legend.add_face(RectFace(heatmap_width, heatmap_height, color1, color1), 0)
                                        ts.legend.add_face(TextFace(" %0.4f"%heatmap_max_value), 1)
                                        if heatmap_center_value > heatmap_min_value:
                                            ts.legend.add_face(RectFace(heatmap_width, heatmap_height, "black", heatmap_color_center), 0)
                                            ts.legend.add_face(TextFace(" %0.4f"%heatmap_center_value), 1)
                                        ts.legend.add_face(RectFace(heatmap_width, heatmap_height, color2, color2), 0)
                                        ts.legend.add_face(TextFace(" %0.4f"%heatmap_min_value), 1)
                                        ts.legend.add_face(RectFace(heatmap_width, heatmap_height, heatmap_color_missing, heatmap_color_missing), 0)
                                        ts.legend.add_face(TextFace(" Missing data"), 1)
                                        heatmap_header_drawn = True
                                                           
                                    for i, value in enumerate(heatmap_data.get(node.name, [])):
                                        ftype_pos[f["pos"]] += 1
                                        if value is None:
                                            color = heatmap_color_missing
                                        elif value > heatmap_center_value:
                                            color = gradient_color(abs(heatmap_center_value - value), heatmap_ref_max, hue=heatmap_color_up)
                                        elif value < heatmap_center_value:
                                            color = gradient_color(abs(heatmap_center_value - value), heatmap_ref_max, hue=heatmap_color_down)
                                        else:
                                            color = heatmap_color_center
                                        rectF = RectFace(heatmap_width, heatmap_height, color, color)
                                        node.add_face(rectF, position="aligned", column=col+i)
                                    F = None
                                    
                                elif f["ftype"] == "profile":
                                    # internal profiles?
                                    F = None
                                elif f["ftype"] == "barchart":
                                    F = None
                                elif f["ftype"] == "piechart":
                                    F = None                                                         
                            
                                # Add the Face
                                if F:
                                    F.opacity = f['opacity'] or 1.0
                                    
                                    # Set face general attributes
                                    if fbgcolor:
                                        F.background.color = fbgcolor

                                    if not f['column']:
                                        col = ftype_pos[f["pos"]]
                                        ftype_pos[f["pos"]] += 1    
                                    else:
                                        col = f["column"]
                                    node.add_face(F, column=col, position=f["pos"])

            if args.image:
                t.render("t%d.%s" %(tindex, args.image),
                         tree_style=ts, w=args.width, h=args.height, units=args.size_units)
            else:
                t.show(None, tree_style=ts)

def parse_value(fvalue):
    func_match = re.search("(\w+)\(([^)]*)\)", fvalue)
    if func_match:
        func_name = func_match.groups()[0]
        func_arg = func_match.groups()[1]
    #RETURN SOMETHING
        
def dump(t, features=None):
    if getattr(args, "output", None):
        t.write(format=0, features=features)
    else:
        print t.write(format=0, features=features)
            
def tree_iterator(tree_source):        
    if not tree_source:
        log.debug("Reading trees from standard input...")
        args.src_trees = sys.stdin
    
    for stree in args.src_trees:

        # CHECK WHAT is needed before process the main command, allows mods before analyses        
        yield stree


## #################################################################################
##
## MAIN ARGUMENT PARSER
##
## #################################################################################
       
def get_parser():        
    main_args_p = argparse.ArgumentParser(add_help=False)
    source_args_p = argparse.ArgumentParser(add_help=False)
    ref_args_p = argparse.ArgumentParser(add_help=False)
    
    _mod_args_p = argparse.ArgumentParser(add_help=False)
    _expand_args_p = argparse.ArgumentParser(add_help=False)
    _split_args_p = argparse.ArgumentParser(add_help=False)
    _extract_args_p = argparse.ArgumentParser(add_help=False)
    

    # output
    
    main_args = main_args_p.add_argument_group('GENERAL OPTIONS')

    main_args.add_argument("-o", dest="output", 
                            type=str,
                            help="""Base output file name""")
    
    main_args.add_argument('--format', dest='newick_format', type=int, default=0)
    
    main_args.add_argument('--features', dest='output_features', type=str, nargs="+", default=[])



    
    main_args.add_argument("--nocolor", dest="nocolor",
                           action="store_true",
                           help="If enabled, it will NOT use colors when logging")

    main_args.add_argument("-v", dest="verbosity",
                           type=int, choices= [0, 1, 2, 3, 4], default=2,
                           help=("Verbosity level: 0=totally quite, 1=errors only,"
                           " 2=warning+errors, 3=info,warnings and errors 4=debug "))
    
    
    # SOURCE     
    source_args = source_args_p.add_argument_group('SOURCE TREES')
    
    source_args.add_argument("-t", dest='src_trees',
                             type=str, nargs="*",
                             help=("a list of trees in newick format (filenames or"
                             " quoted strings)"))
    
    source_args.add_argument("--src_file", dest="src_file", 
                             type=str, 
                             help=("path to a file containing many source trees, one per line"))

    source_args.add_argument("--src_tree_attr", dest="src_tree_attr", 
                             type=str, default="name",
                             help=("attribute in source tree used as leaf name"))
    
    source_args.add_argument("--src_attr_parser", dest="src_attr_parser", 
                             type=str, 
                             help=(""))

    # REFS
    ref_args = ref_args_p.add_argument_group('REFERENCE TREES')
    
    ref_args.add_argument("-r", dest="ref_trees", 
                           type=str, nargs="*",
                           help=("One or more reference trees in newick format (filename"
                                 " or quoted string"))

    ref_args.add_argument("--ref_tree_list", dest="ref_tree_list", 
                             type=str, 
                             help="path to a file containing many ref trees, one per line")
    
    ref_args.add_argument("--ref_tree_attr", dest="ref_tree_attr", 
                           type=str, default="name",
                           help=("attribute in ref tree used as leaf name"))
        
    ref_args.add_argument("--ref_attr_parser", dest="ref_attr_parser", 
                           type=str, 
                           help=(""))

    # MOD
    mod_args = _mod_args_p.add_argument_group('TREE EDIT OPTIONS')
    
    mod_args.add_argument("--outgroup", dest="outgroup", 
                           nargs = "+",
                           help=("Root the tree using the provided outgroup."
                                 " If several names are provided, the first common ancestor grouping"
                                 " all of them will be selected as outgroup."))

    mod_args.add_argument("--ultrametric", dest="ultrametric",
                          type=float, nargs= "*", default="-1",
                           help=("Convert tree into ultrametric (all leaves have the same distance"
                                 " to root). If an argument is provided, it will be used as the"
                                 " expected tree length."))

    mod_args.add_argument("--prune", dest="prune",
                          type=str, nargs= "+",
                           help=("Remove all nodes in the tree except the ones provided."))
    
    mod_args.add_argument("--prune_preserve_lengths", dest="prune_preserve_lengths",
                          action="store_true",
                           help=("branch lengths of the removed nodes are added to the kept branches, "
                                 "thus preserving original tree length."))

    
    mod_args.add_argument("--unroot", dest="unroot",
                          action = "store_true",
                           help="Unroots the tree.")

        
    mod_args.add_argument("--sort_branches", dest="sort", 
                           action="store_true",
                           help="""Sort branches according to node names.""")

    mod_args.add_argument("--ladderize", dest="ladderize", 
                           action="store_true",
                           help="""Sort branches by partition size.""")
    
    mod_args.add_argument("--resolve_polytomies", dest="resolve_polytomies", 
                          action='store_true',
                           help="""Converts polytomies into random bifurcations""")


    # split options
    split_args = _split_args_p.add_argument_group('TREE SPLIT OPTIONS')

    split_args.add_argument("--size_split", dest="split_at_size", 
                          type = int,
                          help=""" """)

    split_args.add_argument("--attr_split", dest="split_at_attr", action='append',
                          type = str, 
                          help=""" """) #    "@dist > 10, @support >= 0.9 "
    
    
    split_args.add_argument("--dup_split", dest="split_at_duplications", 
                          type = str, 
                          help=""" """) # split where attr is duplicated 

    # expand 
    expand_args = _expand_args_p.add_argument_group('TREE EXPAND OPTIONS')
    
    expand_args.add_argument("--treeko_split", dest="treeko_split", 
                          type = str, 
                          help=""" """)

    # extract 
    extract_args = _extract_args_p.add_argument_group('TREE EDIT OPTIONS')

    extract_args.add_argument("--orthologs", dest="orthologs",
                              action="store_true",
                              help="")
    
    extract_args.add_argument("--duplications", dest="duplications",
                              action="store_true",
                              help="a")
    
    extract_args.add_argument("--sptrees", dest="sptrees",
                              action="store_true",
                              help="Extract treeko species trees")
       

    extract_args.add_argument("--edges", dest="edges",
                              action="store_true",
                              help="a")
       
    
    # SUBPROGRAMS
    parser = argparse.ArgumentParser(description="",
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
                                     
    subparser = parser.add_subparsers(title="AVAILABLE PROGRAMS")


    # CONVERT 
    # convert_args_p = subparser.add_parser("convert", parents=[source_args_p, main_args_p],
    #                                    description="",
    #                                    formatter_class=argparse.RawDescriptionHelpFormatter)
    # convert_args_p.set_defaults(func=ete_convert)

    
    # consense
    # consense_args_p = subparser.add_parser("consense", parents=[source_args_p, main_args_p],
    #                                    description="",
    #                                    formatter_class=argparse.RawDescriptionHelpFormatter)
    # consense_args_p.set_defaults(func=ete_consense)

    
    # merge

    
    # RECONCILE
    
    # reconcile_args_p = subparser.add_parser("reconcile", parents=[source_args_p, main_args_p],
    #                                    description="",
    #                                    formatter_class=argparse.RawDescriptionHelpFormatter)
    # reconcile_args_p.set_defaults(func=ete_reconcile)

    
    # maptrees
    # maptrees_args_p = subparser.add_parser("maptrees", parents=[source_args_p, main_args_p],
    #                                    description="",
    #                                    formatter_class=argparse.RawDescriptionHelpFormatter)
    # maptrees_args_p.set_defaults(func=ete_maptrees)

    
    # annotate
    annotate_args_p = subparser.add_parser("annotate", parents=[source_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    annotate_args_p.set_defaults(func=ete_annotate)
    annotate_args = annotate_args_p.add_argument_group("TREE ANNOTATE OPTIONS")
    annotate_args.add_argument("--ncbi", dest="ncbi", action="store_true",
                               help="annotate tree nodes using ncbi taxonomy database.")
    annotate_args.add_argument("--taxid_attr", dest="taxid_attr", default='name',
                               help="attribute used as NCBI taxid number")
    annotate_args.add_argument("--feature", dest="feature", nargs="+", action='append', default=[],
                               help="")
    
    
    # MOD
    mod_args_p = subparser.add_parser("mod", parents=[source_args_p, _mod_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    mod_args_p.set_defaults(func=ete_mod)

    # EXPAND
    expand_args_p = subparser.add_parser("expand", parents=[source_args_p, _expand_args_p,
                                                            main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    expand_args_p.set_defaults(func=ete_expand)

    # SPLIT
    split_args_p = subparser.add_parser("split", parents=[source_args_p, _split_args_p,
                                                          main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    split_args_p.set_defaults(func=ete_split)

    # EXTRACT
    extract_args_p = subparser.add_parser("extract", parents=[source_args_p, _extract_args_p,
                                                              main_args_p],
                                          description="",
                                          formatter_class=argparse.RawDescriptionHelpFormatter)
    extract_args_p.set_defaults(func=ete_extract)

    
    # COMPARE
    COMPARE_DESC = """
 - ete compare -
 
'compare' is a tool to calculate the distance from one or more trees to a
reference tree. Robinson foulds and strict congruence measures are calculated,
among other stats.

Comparisons between trees with different sizes and containing duplicated
attributes are also supported.  names.

%s
  
"""% __CITATION__

    compare_args_p = subparser.add_parser("compare", parents=[source_args_p, _mod_args_p, ref_args_p, main_args_p],
                                           description=COMPARE_DESC, formatter_class=argparse.RawDescriptionHelpFormatter)
    compare_args_p.set_defaults(func=ete_compare)
    
    compare_args = compare_args_p.add_argument_group("COMPARE GENERAL OPTIONS")
    
    compare_args.add_argument("--min_support_ref",
                              type=float, default=0.0,
                              help=("min support for branches to be considered from the ref tree"))
    compare_args.add_argument("--min_support_src",
                              type=float, default=0.0,
                              help=("min support for branches to be considered from the source tree"))
      
    compare_args.add_argument("--unrooted", dest="unrooted", 
                              action = "store_true",
                              help="""compare trees as unrooted""")

    compare_args.add_argument("--diff", dest="differences", 
                              action = "store_true",
                              help="return differences between pairs of trees ")
                                
    # VIEW
    VIEW_DESC = """
 - ete view -
 
The ETE toolkit viewer
%s
  
"""% __CITATION__

    view_args_p = subparser.add_parser( "view", parents=[source_args_p, _mod_args_p, main_args_p],
                                        description=VIEW_DESC, formatter_class=argparse.RawDescriptionHelpFormatter)
    
    view_args_p.set_defaults(func=ete_view)

    
    view_args_p.add_argument("--face", action="append",
                             help="adds a face to the selected nodes. In example --face 'value:@dist, pos:b-top, color:red, size:10, if:@dist>0.9' ")
    
    img_gr = view_args_p.add_argument_group("TREE IMAGE GENERAL OPTIONS")
        
    img_gr.add_argument("-m", "--mode", dest="mode", 
                        choices=["c", "r"], default="r",
                        help="""(r)ectangular or (c)ircular visualization""")
  

    img_gr.add_argument("-i", "--image", dest="image", 
                        type=str, 
                        help="Render tree image instead of showing it. A filename "
                        " should be provided. PDF, SVG and PNG file extensions are"
                        " supported (i.e. -i tree.svg)"
                        )

    img_gr.add_argument("--text", dest="text_mode", 
                        action="store_true",
                        help="Shows the tree using ASCII characters")

    img_gr.add_argument("--attr", "--show_attributes", dest="show_attributes", 
                        nargs="+",
                        help="Display the value of the specified attributes, if available")    
    
    img_gr.add_argument("--Iw", "--width", dest="width", 
                        type=int, default=0, 
                        help="width of the rendered image in pixels (see --size-units)."
                        )

    img_gr.add_argument("--Ih", "--height", dest="height", 
                        type=int, default=0,
                        help="height of the rendered image in pixels (see --size-units)."
                        )

    img_gr.add_argument("--Ir", "--resolution", dest="resolution", 
                        type=int, default=300,
                        help="Resolution if the tree image (DPI)"
                        )

    img_gr.add_argument("--Iu", "--size_units", dest="size_units", 
                        choices=["px", "mm", "in"], default="px",
                        help="Units used to specify the size of the image."
                        " (px:pixels, mm:millimeters, in:inches). "
                        )

    img_gr.add_argument("-mbs", "--min_branch_separation", dest="branch_separation", 
                        type=int, default = 0, 
                        help="Min number of pixels to separate branches vertically."
                        )

    img_gr.add_argument("--ss", "--show_support", dest="show_support", 
                        action="store_true",
                        help="""Shows branch bootstrap/support values""")

    img_gr.add_argument("--sbl", "--show_branch_length", dest="show_branch_length", 
                        action="store_true",
                        help="""Show branch lengths.""")

    img_gr.add_argument("--ft", "--force_topology", dest="force_topology", 
                        action="store_true",
                        help="""Force branch length to have a minimum length in the image""")

    img_gr.add_argument("--hln", "--hide_leaf_names", dest="hide_leaf_names", 
                        action="store_true",
                        help="""Hide leaf names.""")

    img_gr.add_argument("--sin", "--show_internal_names", dest="show_internal_names", 
                        action="store_true",
                        help="""Show the name attribute of all internal nodes.""")

    img_gr.add_argument("--tree_width", dest="tree_width", 
                        type=int, default=300,
                        help=("Adjust tree scale so the distance from root to the"
                              " farthest leaf uses a fixed width in pixels."))
    
    edit_gr = view_args_p.add_argument_group("TREE EDIT OPTIONS")
    
    edit_gr.add_argument("--color_by_rank", dest="color_by_rank", 
                         type=str, nargs="+",
                         help="""If the attribute rank is present in nodes """)

    edit_gr.add_argument("--raxml", dest="raxml", 
                        action="store_true",
                         help=("Parses the newick string and extracts bootstrap values from"
                         " a non-standard RAxML newick file (i.e '((A,B)[100]);'"))
    
    phylo_gr = view_args_p.add_argument_group("PHYLOGENETIC OPTIONS")
    
    phylo_gr.add_argument("--alg", dest="alg", 
                        type=str, 
                        help="""Link tree to a multiple sequence alignment.""")

    phylo_gr.add_argument("--alg_type", dest="alg_type", 
                          choices=['blockseq', 'compactseq', 'fullseq'], default='blockseq',
                          help="How sequence alignment should be drawn in the tree")


    phylo_gr.add_argument("--alg_format", dest="alg_format", 
                        type=str, default="fasta",
                        help="fasta, phylip, iphylip, relaxed_iphylip, relaxed_phylip.")

    phylo_gr.add_argument("--ncbi", dest="as_ncbi", 
                          action="store_true" ,
                          help="""If enabled, default style will be applied to show ncbi taxonomy annotations""")
    
    
    features_gr = view_args_p.add_argument_group("DRAWING FEATURES")
    
    features_gr.add_argument("--heatmap", dest="heatmap", 
                             type=str, 
                             help=("A matrix of tab delimited numeric values where each line corresponds to a leaf node."
                                   "Format: NodeName value1 value2 value3. A header can be also specified in the file as:"
                                   " #NAMES col1 col2 col3"))
    
    features_gr.add_argument("--heatmap_center", dest="heatmap_center_value", 
                             type=float, default=None,
                             help=("center value used to separate values from the heatmap matrix. "
                                   "If provided, values lower than the center will be plotted using a "
                                   "different color scale (--heatmap_color_down))."))
    
    features_gr.add_argument("--heatmap_color_up", dest="heatmap_color_up", 
                             type=float, default=0.3,
                             help=("A HUE color value between 0 and 1 used to create the gradient applied"
                                   " applied when plotting a heatmap matrix"))
    
    features_gr.add_argument("--heatmap_color_down", dest="heatmap_color_down", 
                             type=float, default=0.05,
                             help=("A HUE color value between 0 and 1 used to create the gradient applied"
                                   " to values lower than heatmap_center_value when plotting a heatmap matrix"))

    features_gr.add_argument("--heatmap_height", dest="heatmap_height", 
                             type=int, default=20,
                             help=("Height of the squares in the heatmap plot"))
    features_gr.add_argument("--heatmap_width", dest="heatmap_width", 
                             type=int, default=20,
                             help=("width of the squares in the heatmap plot"))

    
    features_gr.add_argument("--profile", dest="profile", 
                          type=str, 
                          help="...")
    
    features_gr.add_argument("--bubbles", dest="bubbles", 
                          type=str, 
                          help="...")

    # NCBIQUERY    
    ncbi_args_p = subparser.add_parser( "ncbiquery", parents=[main_args_p])

    ncbi_args_p.set_defaults(func=ete_ncbiquery)

    ncbi_args = ncbi_args_p.add_argument_group('NCBI GENERAL OPTIONS')

    ncbi_args.add_argument("--search", dest="search", nargs="+", help="A list of taxid or species names")
    
    ncbi_args.add_argument("--db",  dest="dbfile",
                        type=str,
                        help="""NCBI sqlite3 db file.""")

    ncbi_args.add_argument("--fuzzy", dest="fuzzy", type=float,
                        help=("Tries a fuzzy (and SLOW) search for those"
                              " species names that could not be translated"
                              " into taxids. A float number must be provided"
                              " indicating the minimum string similarity."))

    output_args = ncbi_args_p.add_argument_group('NCBI OUTPUT OPTIONS')
    
    output_args.add_argument("--taxonomy", dest="taxonomy",   
                        action='store_true', 
                        help=("dump a pruned version of the NCBI taxonomy"
                              " tree containing target species into the specified file"))

    output_args.add_argument("--info", dest="info",   
                        action='store_true', 
                        help="""dump NCBI taxonmy information for each target species into the specified file. """)
    
    output_args.add_argument("--collapse_subspecies", dest="collapse_subspecies",   
                        action="store_true",
                        help=("When used, all nodes under the the species rank"
                              " are collapsed, so all species and subspecies"
                              " are seen as sister nodes"))

    output_args.add_argument("--rank_limit", dest="rank_limit",   
                        type=str,
                        help=("When used, all nodes under the provided rank"
                              " are discarded"))
    
    output_args.add_argument("--full_lineage", dest="full_lineage",   
                        action="store_true",
                        help=("When used, topology is not pruned to avoid "
                              " one-child-nodes, so the complete lineage"
                              " track leading from root to tips is kept."))


    # GENERATE  TREES
    generate_args_p = subparser.add_parser("generate", parents=[source_args_p, main_args_p],
                                           description="",
                                           formatter_class=argparse.RawDescriptionHelpFormatter)
    
    generate_args_p.set_defaults(func=ete_generate)

    generate_args_p.add_argument('--number', dest='number', type=int, default=1)
    generate_args_p.add_argument('--size', dest='size', type=int, default=10)
    generate_args_p.add_argument('--random_branches', dest='random_branches', action="store_true")

    return parser
if __name__== "__main__":
    
    parser = get_parser()
    args = parser.parse_args()

    LOG_LEVEL = args.verbosity 
    
    if hasattr(args, "src_trees"):
        args.src_tree_iterator = tree_iterator(args.src_trees)
        
    elif hasattr(args, "search"):
        if not args.search:
            log.debug("Reading taxa from standard input...")
            args.search = sys.stdin 
       

    # Call main program
    args.func(args)

