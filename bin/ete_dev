#!/usr/bin/env python
import sys
import argparse
from string import strip
import re
import operator
from collections import defaultdict
import random


from ete_dev import Tree, PhyloTree, TextFace, faces, TreeStyle, add_face_to_node, random_color
from ete_dev.utils import print_table

from common import parse_faces, node_matcher



__CITATION__ = '''#       ** If you use this software for a published work, please cite: **
#  
# Jaime Huerta-Cepas, Joaquin Dopazo and Toni Gabaldon. ETE: a python Environment
# for Tree Exploration. BMC Bioinformatics 2010, 11:24. doi: 10.1186/1471-2105-11-24.'''

FACES = []

def ete_generate(args):
    for n in xrange(args.number):
        t = Tree()
        t.populate(args.size, random_branches=args.random_branches)
        dump(t, args)

def ete_mod(args):
    for nw in args.src_tree_iterator:
        t = Tree(nw)
        mod_tree(t, args)
        dump(t, args)

def mod_tree(t, args):
    if args.ladderize and args.sort:
        raise ValueError("--sort-branches and --ladderize options are mutually exclusive")

    if args.expand_polytomies:
        t.expand_polytomies(polytomy_size_limit=args.expand_polytomy)
    
    if args.outgroup:
        if len(args.outgroup) > 1:
            outgroup = t.get_common_ancestor(args.outgroup)
        else:
            outgroup = t & args.outgroup[0]
        t.set_outgroup(outgroup)

    if args.ladderize:
        t.ladderize()
    if args.sort:
        t.sort_descendants()

    # ultrametric
    # unroot
    # remove, prune branches
    # resolve polytomies
        
def ete_split(args):
    pass

def ete_expand(args):
    pass

def ete_extract(args):
    #dups, orthologs, partitions, edges, dist_matrix, ancestor, 
    pass

def ete_consense(args):
    pass

def ete_ncbiquery(args):
    pass

def ete_annotate(args):
    pass

def ete_convert(args):
    pass

def ete_maptrees(args):
    pass

def ete_fetch(args):
    pass

def ete_codeml(args):
    pass

def ete_reconcile(args):
    pass
    
def ete_compare(args):
    def iter_differences(set1, set2, unrooted=False):
        for s1 in set1:
            pairs = []
            for r1 in set2:
                if unrooted:
                    d = euc_dist_unrooted(s1, r1)
                else:
                    d = euc_dist(s1, r1)
                if d < 1:
                    pairs.append((d,r1))
            yield s1, pairs
    
    for stree_name in args.src_tree_iterator:
        stree = Tree(stree_name)
        for rtree_name in args.ref_trees:
            rtree = Tree(rtree_name)
            r = stree.compare(rtree, 
                              ref_tree_attr=args.ref_tree_attr,
                              source_tree_attr=args.src_tree_attr,
                              min_support_ref=args.min_support_ref,
                              min_support_source = args.min_support_src,
                              unrooted=args.unrooted,
                              has_duplications=False)


            col_sizes = [25, 25] + [8] * 8
            print_table([map(as_str, [shorten_str(stree_name,25), shorten_str(rtree_name,25), r['effective_tree_size'], r['norm_rf'], 
                                    r['rf'], r['max_rf'], r["source_edges_in_ref"],
                                    r["ref_edges_in_source"], r['source_subtrees'], r['treeko_dist']])],
                        fix_col_width = col_sizes, wrap_style='cut')

            if args.differences:
                from pprint import pprint
                import itertools

                mismatches_src = r['source_edges'] - r['ref_edges']
                mismatches_ref = r['ref_edges'] - r['source_edges']
                for part, pairs in iter_differences(mismatches_src, mismatches_ref, unrooted=args.unrooted):
                    print part
                    for d, r in sorted(pairs):
                        print "  ", d, r
 
                
def ete_view(args):
    global FACES
    if args.face:
        FACES = parse_faces(args.face)
    else:
        FACES = []

    # VISUALIZATION
    ts = TreeStyle()
    ts.mode = args.mode
    ts.show_leaf_name = True

    for f in FACES:
        if f["value"] == "@name":
            ts.show_leaf_name = False
            break
    
    ts.branch_vertical_margin = args.branch_separation
    if args.show_support:
        ts.show_branch_support = True
    if args.show_branch_length:
        ts.show_branch_length = True
    if args.force_topology:
        ts.force_topology = True
    ts.layout_fn = lambda x: None
        
    for tfile in args.src_tree_iterator:
        if args.raxml:
            nw = re.sub(":(\d+\.\d+)\[(\d+)\]", ":\\1[&&NHX:support=\\2]", open(tfile).read())
            t = PhyloTree(nw)
        else:
            t = PhyloTree(tfile)

        if args.ncbi:
            if args.taxid_attr_regexp:
                TAXIDMATCHER = re.compile(args.taxid_attr_regexp)

            for lf in t:
                if args.taxid_attr_regexp:
                    lf.taxid = re.search(TAXIDMATCHER, getattr(lf, args.taxid_attr)).groups()[0]
                else:
                    lf.taxid = getattr(lf, args.taxid_attr)
            t.annotate_ncbi_taxa(taxid_attr="taxid")

        if args.alg:
            t.link_to_alignment(args.alg, alg_format=args.alg_format)
            LEAF_ATTRIBUTES["sequence"] = 1 #################

        if args.outgroup:
            if len(args.outgroup) > 1:
                outgroup = t.get_common_ancestor(args.outgroup)
            else:
                outgroup = t & args.outgroup[0]
            t.set_outgroup(outgroup)

        # scale the tree
        if not args.height: 
            args.height = None
        if not args.width: 
            args.width = None

        if args.text_mode:
            print t.get_ascii(show_internal=args.show_internal_names, attributes = args.show_attributes)
        else:    
            f2color = {}
            f2last_seed = {}
            for node in t.traverse():
                node.img_style['size'] = 0

                ftype_pos = defaultdict(int)
                for f in FACES:
                    last_seed = f2last_seed.setdefault(f["value"], random.random())
                    if (f['nodetype'] == 'any' or 
                        (f['nodetype'] == 'leaf' and node.is_leaf()) or
                        (f['nodetype'] == 'internal' and not node.is_leaf())):            
                        if node_matcher(node, f["filters"]):
                            if f["value"].startswith("@"):
                                attr = getattr(node, f["value"][1:], None)
                            else:
                                attr = f["value"]                    
                            if attr != None:
                                if f['color'] == 'auto()':
                                    seed = last_seed + 0.10 + random.uniform(0.1, 0.2)
                                    f2last_seed[f["value"]] = seed
                                    color = f2color.setdefault(attr, random_color(h=seed))

                                else:
                                    color = f['color']
                                F = TextFace(attr,
                                             fsize=f.get("size", 10),
                                             fgcolor=color)

                                if f['bgcolor']:
                                    F.background.color = f['bgcolor']

                                if not f['column']:
                                    col = ftype_pos[f["pos"]]
                                    ftype_pos[f["pos"]] += 1    
                                else:
                                    col = f["column"]
                                # Add the Face
                                node.add_face(F, column=col, position=f["pos"])


            if args.image:
                t.render(args.image, tree_style=ts, w=args.width, h=args.height, units=args.size_units)
            else:
                t.show(None, tree_style=ts)

        
def dump(t, args):
    if getattr(args, "output", None):
        t.write(format=args.newick_format, features=args.output_features)
    else:
        print t.write(format=args.newick_format, features=args.output_features)
            
def tree_iterator(tree_source):        
    if not tree_source:
        args.src_trees = sys.stdin
    
    for stree in args.src_trees:

        # CHECK WHAT is needed before process the main command, allows mods before analyses
        
        yield stree


## #################################################################################
##
## MAIN ARGUMENT PARSER
##
## #################################################################################
       
        
if __name__=="__main__":
    main_args_p = argparse.ArgumentParser(add_help=False)
    source_args_p = argparse.ArgumentParser(add_help=False)
    ref_args_p = argparse.ArgumentParser(add_help=False)
    
    _mod_args_p = argparse.ArgumentParser(add_help=False)
    _expand_args_p = argparse.ArgumentParser(add_help=False)
    _split_args_p = argparse.ArgumentParser(add_help=False)
    _extract_args_p = argparse.ArgumentParser(add_help=False)
    

    # output
    
    main_args = main_args_p.add_argument_group('GENERAL OPTIONS')

    main_args.add_argument("-o", dest="output", 
                            type=str,
                            help="""Base output file name""")

    
    main_args.add_argument('--format', dest='newick_format', type=int, default=1)
    main_args.add_argument('--features', dest='output_features', type=str, nargs="+", default=[])

    
    main_args.add_argument("--quite", dest="quite",
                        action="store_true",
                        help="Do not show process information")
    
    main_args.add_argument("--color", dest="color",
                           action="store_true",
                           help="If enabled, it will use colors in some of the report")

    
    # SOURCE     
    source_args = source_args_p.add_argument_group('SOURCE TREES')
    
    source_args.add_argument("-t", dest='src_trees',
                             type=str, nargs="*",
                             help='a list of trees in newick format (filenames or quoted strings)')
    
    source_args.add_argument("--src_file", dest="src_file", 
                             type=str, 
                             help="""path to a file containing many source trees, one per line""")

    source_args.add_argument("--src_tree_attr", dest="src_tree_attr", 
                             type=str, default="name",
                             help=("attribute in source tree used as leaf name"))
    
    source_args.add_argument("--src_attr_parser", dest="src_attr_parser", 
                             type=str, 
                             help=(""))

    # REFS
    ref_args = ref_args_p.add_argument_group('REFERENCE TREES')
    
    ref_args.add_argument("-r", dest="ref_trees", 
                           type=str, nargs="*",
                           help="One or more reference trees in newick format (filename or quoted string")

    ref_args.add_argument("--ref_tree_list", dest="ref_tree_list", 
                             type=str, 
                             help="path to a file containing many ref trees, one per line")

    
    ref_args.add_argument("--ref_tree_attr", dest="ref_tree_attr", 
                           type=str, default="name",
                           help=("attribute in ref tree used as leaf name"))
    
    
    ref_args.add_argument("--ref_attr_parser", dest="ref_attr_parser", 
                           type=str, 
                           help=(""))

    # MOD
    mod_args = _mod_args_p.add_argument_group('TREE EDIT OPTIONS')
    
    mod_args.add_argument("--outgroup", dest="outgroup", 
                           nargs = "+",
                           help="""outgroup used to root reference and source trees before distance computation""")

        
    mod_args.add_argument("--sort_branches", dest="sort", 
                           action="store_true",
                           help="""Sort branches according to node names.""")

    mod_args.add_argument("--ladderize", dest="ladderize", 
                           action="store_true",
                           help="""Sort branches by partition size.""")
    
    mod_args.add_argument("--expand_polytomies", dest="expand_polytomies", 
                          type=int, default=6, 
                           help="""Expand all polytomies larger than the provided size""")


    # split options
    split_args = _split_args_p.add_argument_group('TREE SPLIT OPTIONS')

    split_args.add_argument("--size_split", dest="split_at_size", 
                          type = int,
                          help=""" """)

    split_args.add_argument("--attr_split", dest="split_at_attr", action='append',
                          type = str, 
                          help=""" """) #    "@dist > 10, @support >= 0.9 "
    
    
    split_args.add_argument("--dup_split", dest="split_at_duplications", 
                          type = str, 
                          help=""" """) # split where attr is duplicated 

    # expand 
    expand_args = _expand_args_p.add_argument_group('TREE EXPAND OPTIONS')

    expand_args.add_argument("--expand_polytomies", dest="polytomies", 
                           action = "store_true",
                           help="""expand politomies if necessary""")

    
    expand_args.add_argument("--treeko_split", dest="treeko_split", 
                          type = str, 
                          help=""" """)

    # extract 
    extract_args = _extract_args_p.add_argument_group('TREE EDIT OPTIONS')

    extract_args.add_argument("--attr", dest="split_at_attr", action='append', 
                          type = str, 
                          help=""" """)
       
    


    
    # SUBPROGRAMS
    parser = argparse.ArgumentParser(description="",
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
                                     
    subparser = parser.add_subparsers(title="AVAILABLE PROGRAMS")


    # CONVERT 
    convert_args_p = subparser.add_parser("convert", parents=[source_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    convert_args_p.set_defaults(func=ete_convert)

    
    # consense
    consense_args_p = subparser.add_parser("consense", parents=[source_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    consense_args_p.set_defaults(func=ete_consense)

    
    # merge

    
    # RECONCILE
    
    reconcile_args_p = subparser.add_parser("reconcile", parents=[source_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    reconcile_args_p.set_defaults(func=ete_reconcile)

    
    # maptrees
    maptrees_args_p = subparser.add_parser("maptrees", parents=[source_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    maptrees_args_p.set_defaults(func=ete_maptrees)

    
    # annotate

    annotate_args_p = subparser.add_parser("annotate", parents=[source_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    annotate_args_p.set_defaults(func=ete_annotate)

    
    
    # MOD
    mod_args_p = subparser.add_parser("mod", parents=[source_args_p, _mod_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    mod_args_p.set_defaults(func=ete_mod)

    # EXPAND
    expand_args_p = subparser.add_parser("expand", parents=[source_args_p, _expand_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    expand_args_p.set_defaults(func=ete_expand)

    # SPLIT
    split_args_p = subparser.add_parser("split", parents=[source_args_p, _split_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    split_args_p.set_defaults(func=ete_split)

    # EXTRACT
    extract_args_p = subparser.add_parser("extract", parents=[source_args_p, _extract_args_p, main_args_p],
                                       description="",
                                       formatter_class=argparse.RawDescriptionHelpFormatter)
    extract_args_p.set_defaults(func=ete_extract)


    
    # COMPARE
    COMPARE_DESC = """
 - ete compare -
 
'compare' is a tool to calculate the distance from one or more trees to a
reference tree. Robinson foulds and strict congruence measures are calculated,
among other stats.

Comparisons between trees with different sizes and containing duplicated
attributes are also supported.  names.

%s
  
"""% __CITATION__

    compare_args_p = subparser.add_parser("compare", parents=[source_args_p, _mod_args_p, ref_args_p, main_args_p],
                                           description=COMPARE_DESC, formatter_class=argparse.RawDescriptionHelpFormatter)
    compare_args_p.set_defaults(func=ete_compare)
    
    compare_args = compare_args_p.add_argument_group("COMPARE GENERAL OPTIONS")
    
    compare_args.add_argument("--min_support_ref",
                              type=float, default=0.0,
                              help=("min support for branches to be considered from the ref tree"))
    compare_args.add_argument("--min_support_src",
                              type=float, default=0.0,
                              help=("min support for branches to be considered from the source tree"))
      
    compare_args.add_argument("--unrooted", dest="unrooted", 
                              action = "store_true",
                              help="""compare trees as unrooted""")

    compare_args.add_argument("--diff", dest="differences", 
                              action = "store_true",
                              help="return differences between pairs of trees ")
                                
    # VIEW
    VIEW_DESC = """
 - ete view -
 
The ETE toolkit viewer
%s
  
"""% __CITATION__

    view_args_p = subparser.add_parser( "view", parents=[source_args_p, _mod_args_p, main_args_p],
                                        description=VIEW_DESC, formatter_class=argparse.RawDescriptionHelpFormatter)
    
    view_args_p.set_defaults(func=ete_view)

    
    view_args_p.add_argument("--face", action="append",
                             help="adds a face to the selected nodes. In example --face 'value:@dist, pos:b-top, color:red, size:10, if:@dist>0.9' ")
    
    img_gr = view_args_p.add_argument_group("TREE IMAGE GENERAL OPTIONS")
        
    img_gr.add_argument("-m", "--mode", dest="mode", 
                        choices=["c", "r"], default="r",
                        help="""(r)ectangular or (c)ircular visualization""")
  

    img_gr.add_argument("-i", "--image", dest="image", 
                        type=str, 
                        help="Render tree image instead of showing it. A filename "
                        " should be provided. PDF, SVG and PNG file extensions are"
                        " supported (i.e. -i tree.svg)"
                        )

    img_gr.add_argument("--text", dest="text_mode", 
                        action="store_true",
                        help="Shows the tree using ASCII characters")

    img_gr.add_argument("--attr", "--show_attributes", dest="show_attributes", 
                        nargs="+",
                        help="Display the value of the specified attributes, if available")    
    
    img_gr.add_argument("--Iw", "--width", dest="width", 
                        type=int, default=0, 
                        help="width of the rendered image in pixels (see --size-units)."
                        )

    img_gr.add_argument("--Ih", "--height", dest="height", 
                        type=int, default=0,
                        help="height of the rendered image in pixels (see --size-units)."
                        )

    img_gr.add_argument("--Ir", "--resolution", dest="resolution", 
                        type=int, default=300,
                        help="Resolution if the tree image (DPI)"
                        )

    img_gr.add_argument("--Iu", "--size_units", dest="size_units", 
                        choices=["px", "mm", "in"], default="px",
                        help="Units used to specify the size of the image."
                        " (px:pixels, mm:millimeters, in:inches). "
                        )

    img_gr.add_argument("-mbs", "--min_branch_separation", dest="branch_separation", 
                        type=int, default = 3, 
                        help="Min number of pixels to separate branches vertically."
                        )

    img_gr.add_argument("--ss", "--show_support", dest="show_support", 
                        action="store_true",
                        help="""Shows branch bootstrap/support values""")

    img_gr.add_argument("--sbl", "--show_branch_length", dest="show_branch_length", 
                        action="store_true",
                        help="""Show branch lengths.""")

    img_gr.add_argument("--ft", "--force_topology", dest="force_topology", 
                        action="store_true",
                        help="""Force branch length to have a minimum length in the image""")

    img_gr.add_argument("--hln", "--hide_leaf_names", dest="hide_leaf_names", 
                        action="store_true",
                        help="""Hide leaf names.""")

    img_gr.add_argument("--sin", "--show_internal_names", dest="show_internal_names", 
                        action="store_true",
                        help="""Show the name attribute of all internal nodes.""")

    edit_gr = view_args_p.add_argument_group("TREE EDIT OPTIONS")
    
    edit_gr.add_argument("--color_by_rank", dest="color_by_rank", 
                         type=str, nargs="+",
                         help="""If the attribute rank is present in nodes """)

    edit_gr.add_argument("--ncbi", dest="ncbi", 
                         action='store_true',
                         help=("Annotate tree using the NCBI taxonomy database. --src_target_attr"
                               " and --src_attr_regexp will be used to parse taxid from tree nodes."))

    edit_gr.add_argument("--raxml", dest="raxml", 
                        action="store_true",
                         help=("Parses the newick string and extracts bootstrap values from"
                         " a non-standard RAxML newick file (i.e '((A,B)[100]);'"))
    
    phylo_gr = view_args_p.add_argument_group("PHYLOGENETIC OPTIONS")
    
    phylo_gr.add_argument("--alg", dest="alg", 
                        type=str, 
                        help="""Link tree to a multiple sequence alignment.""")

    phylo_gr.add_argument("--alg_format", dest="alg_format", 
                        type=str, default="fasta",
                        help="fasta, phylip, iphylip, relaxed_iphylip, relaxed_phylip.")
    
    phylo_gr.add_argument("--sp_discovery", dest="species_discovery_regexp", 
                          type=str, default="^[^_]+_(.+)",
                          help="Perl regular expression used to capture species"
                          " code from node names. By default, node names"
                          " are expected to follow the NAME_SPCODE format = '^[^_]+_(.+)' ")

    features_gr = view_args_p.add_argument_group("DRAWING FEATURES")
    
    phylo_gr.add_argument("--heatmap", dest="alg", 
                        type=str, 
                          help="""attr_name \t v1, v2, v3, v4""")

    phylo_gr.add_argument("--profile", dest="alg", 
                        type=str, 
                          help="""attr_name \t v1, v2, v3, v4""")
    
    phylo_gr.add_argument("--bubbles", dest="alg", 
                        type=str, 
                        help=""" """)

    # NCBIQUERY    
    ncbi_args_p = subparser.add_parser( "ncbiquery", parents=[source_args_p, main_args_p])

    ncbi_args = ncbi_args_p.add_argument_group('NCBI GENERAL OPTIONS')
    
    ncbi_args.add_argument("--db",  dest="dbfile",
                        type=str,
                        help="""NCBI sqlite3 db file.""")

    input_args = ncbi_args_p.add_argument_group('TAXID INPUT OPTIONS')
    
    input_args.add_argument("-i", "--taxid", dest="taxid", nargs="+",  
                        type=int, 
                        help="""taxids (space separated)""")

    input_args.add_argument("-if", "--taxid_file", dest="taxid_file",   
                        type=str, 
                        help="""file containing a list of taxids (one per line)""")


    name_input_args = ncbi_args_p.add_argument_group('NAME INPUT OPTIONS')
    
    name_input_args.add_argument("-n", "--name", dest="names", nargs="+",  
                        type=str, 
                        help="""species or taxa names (comma separated)""")

    name_input_args.add_argument("-nf", "--names_file", dest="names_file",   
                        type=str, 
                        help="""file containing a list of taxids (one per line)""")
    name_input_args.add_argument("--fuzzy", dest="fuzzy", type=float,
                        help=("Tries a fuzzy (and SLOW) search for those"
                              " species names that could not be translated"
                              " into taxids. A float number must be provided"
                              " indicating the minimum string similarity."))

    output_args = ncbi_args_p.add_argument_group('NCBI OUTPUT OPTIONS')
    
    output_args.add_argument("--taxonomy", dest="taxonomy",   
                        action='store_true', 
                        help=("dump a pruned version of the NCBI taxonomy"
                              " tree containing target species into the specified file"))

    output_args.add_argument("--table", dest="info_list",   
                        action='store_true', 
                        help="""dump NCBI taxonmy information for each target species into the specified file. """)

    output_args.add_argument("--annotate", dest="annotated_tree",   
                        action='store_true', 
                        help="dump the annotated tree of the input reftree provided with -t into the specified file.")                             
    
    output_args.add_argument("--collapse_subspecies", dest="collapse_subspecies",   
                        action="store_true",
                        help=("When used, all nodes under the the species rank"
                              " are collapsed, so all species and subspecies"
                              " are seen as sister nodes"))

    output_args.add_argument("--rank_limit", dest="rank_limit",   
                        type=str,
                        help=("When used, all nodes under the provided rank"
                              " are discarded"))
    
    output_args.add_argument("--full_lineage", dest="full_lineage",   
                        action="store_true",
                        help=("When used, topology is not pruned to avoid "
                              " one-child-nodes, so the complete lineage"
                              " track leading from root to tips is kept."))


    # GENERATE  TREES
    
    generate_args_p = subparser.add_parser("generate", parents=[source_args_p, main_args_p],
                                           description="",
                                           formatter_class=argparse.RawDescriptionHelpFormatter)
    
    generate_args_p.set_defaults(func=ete_generate)

    generate_args_p.add_argument('--number', dest='number', type=int, default=1)
    generate_args_p.add_argument('--size', dest='size', type=int, default=10)
    generate_args_p.add_argument('--random_branches', dest='random_branches', action="store_true")

    
    args = parser.parse_args()

    args.src_tree_iterator = tree_iterator(args.src_trees)


    # Call main program
    args.func(args)



