#!/usr/bin/env python

import sys
import os
from collections import defaultdict
from common import Tree, PhyloTree, argparse, add_face_to_node, TreeStyle, faces
import numpy
import hashlib
import gc
import cPickle
md5 = lambda x: hashlib.md5(x).hexdigest()

__DESCRIPTION__ = ''

def get_first_common_branch(observed_items, reftree_content):
    #first common ancestor of the observed_items in the reftree
    smallest_clade = None
    for node, content in reftree_content.iteritems():
        if observed_items.issubset(content):
            if not min_clade or len(reftree_content[smallest_clade]) < len(content):
                smallest_clade = node
    return smallest_clade
                
def minimize_lost_branches(lost_items, reftree_branches):
    """
    given a set of lost items and a sorted list (preorder) of reference tree
    partitions, returns the min number of lost branches explaining all the
    losses.
    """
    lost_branches = []
    for branch, refcontent in reftree_branches:
        if refcontent.issubset(lost_items):
            lost_branches.append(branch)
            lost_items -= refcontent
    return lost_branches

def get_lost_branches(obs_items, expected_items, ref_branch,
                      sorted_ref_branches):

    # Calculate lost items in both sides of the duplication
    lost_items = expected_items - obs_items
    if lost_items:
        # Convert list items into the minimum number of branch losses
        lost_branches = minimize_lost_branches(lost_items, sorted_ref_branches)
    else:
        lost_branches = []
    # Group lost branches
    return lost_branches
   
def process_trees(iter_data, reftree, monitor=False):
    # cache some common data
    reftree_content = reftree.get_cached_content(store_attr="name")
    sorted_ref_branches = [(n, reftree_content[n]) for n in reftree.traverse("preorder")]
    refclades = [(n, reftree_content[n.children[0]], reftree_content[n.children[1]])
                 for n in reftree.traverse("preorder") if not n.is_leaf()]

    informed_branches = defaultdict(int)      # How many trees were used to
                                              # inform about each refTree branch
    
    losses_per_branch = defaultdict(int)      # Number of losses in each refTree branch
    coll_losses_per_branch = defaultdict(int) 
    
    losses_per_dup_branch = defaultdict(list) # Number of losses for duplication
                                              # in each refTreeBranch
    coll_losses_per_dup_branch = defaultdict(list) 
    
    dup_per_branch = defaultdict(list)        # dUplication events sorted by
                                              # refTree branch
    coll_dup_per_branch = defaultdict(list)   
                                              
    refbranch_supports = defaultdict(list)    # gene tree support values for
                                              # each refTree branch
    coll_refbranch_supports = defaultdict(list)    


    skipped_trees = 0
    def take_snapshot():
        print "\nTaking a tree snapshot"
        annotate_tree(reftree, informed_branches, dup_per_branch, losses_per_branch,
                      losses_per_dup_branch, refbranch_supports,
                      coll_dup_per_branch, coll_losses_per_branch,
                      coll_losses_per_dup_branch, coll_refbranch_supports)
        ts = TreeStyle()
        ts.layout_fn = info_layout
        reftree.render("tree_analysis.png", tree_style=ts)
    
    for tree_counter, (treeid, t, tree_content) in enumerate(iter_data):
        if DEBUG:
            print treeid, t
            ts = TreeStyle()
            ts.title.add_face(faces.TextFace("Seedid = %s"%treeid), 1)
            t.render("%s.png"%treeid, tree_style=ts)
                        
        if tree_counter % 100 == 0:
            print >>sys.stderr, "\r% 10d skipped:% 5d" %(tree_counter, skipped_trees),
            sys.stderr.flush()
            gc.collect()
            
        if tree_counter and tree_counter % MONITOR_STEP == 0:
            take_snapshot()
            
        # Compute support of this tree over the whole refTree
        seedid = None if USE_COLLATERAL else treeid
        seedsp = None if USE_COLLATERAL else extract_species(treeid)
        branch2supports, branch2coll_supports = get_supported_branches(t, tree_content,
                                                                     refclades=refclades, seedid=seedid)
        if branch2supports == {} and branch2coll_supports == {}:
            skipped_trees +=1
        # We combine the information of all treeko trees, by averaging the
        # number of subtrees that supported or not a given refTree branch.
        for refbranch, supports in branch2supports.iteritems():
            refbranch_supports[refbranch].append(numpy.mean(supports))
        for refbranch, coll_supports in branch2coll_supports.iteritems():
            coll_refbranch_supports[refbranch].append(numpy.mean(coll_supports))

            
        # Here I keep a counter on how many trees were potentially able to
        # inform about specific reftree branches. For instance, if outgroup
        # species X does not appear in a genetree, I dont want to count this
        # tree as a source for duplication in the X branch.
        all_observed_sp = extract_species([n.name for n in tree_content[t]])
        if len(all_observed_sp) == 1: 
            max_ref_branch = reftree.search_nodes(name=list(all_observed_sp)[0])[0]
        else:
            max_ref_branch = reftree.get_common_ancestor(all_observed_sp)
        for refbranch in max_ref_branch.traverse():
            informed_branches[refbranch] += 1

        # Start analyzing internal nodes
        for node in t.traverse("preorder"):
            if node.is_leaf():
                continue 

            if len(node.children) != 2:
                print node
                raise ValueError("Binary trees are required")

            # Extract the species set at both sides of the node
            ch_left = node.children[0]
            ch_right = node.children[1]
            seqs_left = set([n.name for n in tree_content[ch_left]])
            seqs_right = set([n.name for n in tree_content[ch_right]])
            species_left = extract_species(seqs_left)
            species_right = extract_species(seqs_right)

            # Decide whether this node is a duplication or not
            if DETECT_DUPLICATIONS:
                isdup = True if species_left & species_right else False
            else:
                isdup = True if n.evoltype == "D" else False

            # if this is a dup or the root of tree, map the to node to its
            # corresponding refTree branch and infer the expected list of
            # species
            if isdup or node is t: 
                observed_sp = species_left | species_right
                if len(observed_sp) == 1: 
                    ref_branch = reftree.search_nodes(name=list(observed_sp)[0])[0]
                else:
                    ref_branch = reftree.get_common_ancestor(observed_sp)
                expected_sp = reftree_content[ref_branch]

            if isdup:
                # updates duplications per branch in ref tree (dup rate analysis)
                if USE_COLLATERAL or seedsp in observed_sp:
                    dup_per_branch[ref_branch].append([seqs_left, seqs_right])
                elif not USE_COLLATERAL:
                    coll_dup_per_branch[ref_branch].append([seqs_left, seqs_right])

            # Count losses observed after a duplication or at the root of the tree.
            if isdup or node is t:
                # get a list of losses at both sides of the dupli
                if not isdup and node is t:
                    losses_left = get_lost_branches(observed_sp, expected_sp,
                                                    ref_branch, sorted_ref_branches)
                    losses_right = []
                else:
                    losses_left = get_lost_branches(species_left, expected_sp,
                                                    ref_branch, sorted_ref_branches)
                    losses_right = get_lost_branches(species_right, expected_sp,
                                                     ref_branch, sorted_ref_branches)

                if USE_COLLATERAL:
                    losses = losses_left + losses_right
                    coll_losses = []
                else:
                    if treeid in seqs_left:
                        # if the seed species is not found at the other side of
                        # the dup, we can assume that its losses will never be
                        # counted, so we combine data from both sides.
                        if seedsp not in species_right: 
                            losses = losses_left + losses_right
                        # otherwise, we wait for info for a different seed tree
                        else: 
                            losses = losses_left
                        # No collateral information as data come from a duplication including the seed
                        coll_losses = [] 
                    elif treeid in seqs_right:
                        # if the seed species is not found at the other side of
                        # the dup, we can assume that its losses will never be
                        # counted, so we combine data from both sides.
                        if seedsp not in species_left: 
                            losses = losses_left + losses_right
                        # otherwise, we wait for info for a different seed tree
                        else:
                            losses = losses_right
                        # No collateral information as data come from a duplication including the seed
                        coll_losses = [] 
                    else:
                        # If this is a collateral duplication, process losses as such
                        losses = []
                        coll_losses = losses_left + losses_right

                if len(reftree_content[ref_branch]) == 1 and losses + coll_losses:
                    raw_input("This should never happen")
                    
                # update gene loss counters
                for lost_branch in losses:
                    losses_per_branch[lost_branch] += 1
                    if isdup: # if losses come from a dup event
                        losses_per_dup_branch[ref_branch].append(lost_branch)
                for lost_branch in coll_losses:
                    coll_losses_per_branch[lost_branch] += 1
                    if isdup: # if losses come from a dup event
                        coll_losses_per_dup_branch[ref_branch].append(lost_branch)
                        
    take_snapshot()
    return dup_per_branch, informed_branches, losses_per_branch, losses_per_dup_branch, refbranch_supports
        
def get_supported_branches(source_tree, reftree, refclades, seedid=None):
    """
        Given a reference species tree and a rooted gene tree in which
        duplication events are already mapped, this function does the following:
        
          - Split gene tree into all possible species tree (Treeko method)
          
          - Find matches between each subtree branch and all branches in the
            reference tree. 
          
              - Each branch in each species subtree is compared to all branches
                in the reftree. If left/right side of the subtree branch
                coincide with a the left/right side of a reference tree branch,
                this is considered a gene tree support point. Coincidences must
                comply with the following conditions:

                   - All species in the left/right sides of the subtree branch
                     exist in the left/right sides of the reference branch.

                   - Species in the left/right sides of the reference branch are
                     never mixed in the subtree branch.
                     
                   - Missing species are allowed in the subtree split, only if
                     such species are not present in any other part of the
                     original gene tree.

                   - Support value of the subtree branch is higher than a given
                     cutoff.
    """
    
    # Run Treeko to get all possible species tree combinations. We assume dups are already mapped
    ntrees, ndups, sp_trees = source_tree.get_speciation_trees(autodetect_duplications=DETECT_DUPLICATIONS, newick_only=True)
    if ntrees > 100000:
        return {}
    branches_found = []
    branch2supports = defaultdict(list)
    branch2coll_supports = defaultdict(list)
    for nw in sp_trees:
        # Use all treeko trees or only those subtrees containing the seed?
        if seedid and seedid not in nw:
            container = branch2coll_supports
        else:
            container = branch2supports
            
        subtree = PhyloTree(nw, sp_naming_function = extract_species)
        subtreenode2content = subtree.get_cached_content(store_attr="species")
        #set([phy3(_c.name) for _c in subtreenode2content[subtree]])
        all_sp_in_subtree = subtreenode2content[subtree]
        
        # Visit all nodes in the tree
        for n in subtree.traverse("preorder"):
            if not n.is_leaf():
                c1 = subtreenode2content[n.children[0]]
                c2 = subtreenode2content[n.children[1]]
                #branches_found.append([all_sp_in_subtree, c1, c2])

                for refnode, m1, m2 in refclades:
                    all_expected_sp = m1 | m2

                    # We add one supporting point to every observed split that coincides
                    # with a reference tree branch. This is, seqs in one side and seqs
                    # on the other side of the observed split matches a ref_tree branch
                    # without having extra seqs in any of the sides. However, we allow
                    # for split matches where some seqs are lost in the observed split.
                    
                    #for all_sp_in_subtree, c1, c2 in branches_found:
                    all_seen_sp = c1|c2
                    notfound, found = 0, 0

                    false_missing = (all_expected_sp - all_seen_sp) & all_sp_in_subtree
                    outside_species = (all_seen_sp - all_expected_sp)

                    # Compare expected (m1,m2) splits with observed splits (c1,c2). 
                    a_straight  = m1 & c1
                    b_straight = m2 & c2
                    a_cross = m1 & c2
                    b_cross = m2 & c1

                    # if matches are found for one of the first possible comparison
                    if (a_straight and b_straight):
                        # and the match contains all the observed species, species
                        # from both sides are not mixed and missing species are real
                        if not outside_species and not a_cross and not b_cross and not false_missing:
                            found += 1
                        else:
                            notfound += 1

                    # if matches are found for the second possible comparison (This
                    # would never occur if found variable was increased in the
                    # previous if)
                    if (a_cross and b_cross):
                        # and the match contains all the observed species, species
                        # from both sides are not mixed and missing species are real
                        if not outside_species and not a_straight and not b_straight and not false_missing:
                            found += 1
                        else:
                            notfound += 1

                    if notfound > 0:
                        container[refnode].append(0)
                    elif found > 0:
                        container[refnode].append(1)                    

                    if found == 2:
                        raw_input("Two possible matches? This should never occur!!")
                
    return branch2supports, branch2coll_supports

def dup_iterator(fname):
    for line in open(fname):
        if line.startswith("#") or not line.strip(): continue
        treeid, left, right = map(strip, line.split("\t"))
        seqs_left = set(map(strip, left.split(",")))
        seqs_right = set(map(strip, right.split(",")))
        yield seqs_left, seqs_right, treeid

def extract_species(seq_names):
    if isinstance(seq_names, Tree):
        return seq_names.name.split(SPNAME_DELIMITER)[SPNAME_FIELD]
    elif isinstance(seq_names, str):
        return seq_names.split(SPNAME_DELIMITER)[SPNAME_FIELD]
    else:
        return set(map(lambda name: name.split(SPNAME_DELIMITER)[SPNAME_FIELD], seq_names))
        
def tree_iterator(fname, restrict_species=None):
    for line in open(fname):
        if line.startswith("#") or not line.strip(): continue
        treeid, newick = line.split("\t")
        t = PhyloTree(newick, sp_naming_function=extract_species)
        if restrict_species:
            t.prune([n for n in t.iter_leaves() if n.species in restrict_species])

        n2content = t.get_cached_content()
        if len(n2content[t]) < 2:
            continue
        yield treeid, t, n2content

def info_layout(node):
    if node.ndups is not None:
        add_face_to_node(faces.TextFace("Dups=%d(%0.2g dup/tree)" %(node.ndups, node.dup_rate),
                                        fsize=8, fgcolor="orange"), node, 2, position="branch-bottom")
    if node.losses is not None:
        add_face_to_node(faces.TextFace("Losses=%d(%0.2g losses/tree)" %(node.losses, node.losses_rate),
                                    fsize=8, fgcolor="green"), node, 2, position="branch-bottom")

    if node.nduplosses is not None:
        add_face_to_node(faces.TextFace("dupLosses=%d(%0.2g losses/tree)" %(node.nduplosses, node.duplosses_rate),
                                        fsize=8, fgcolor="blue"), node, 2, position="branch-bottom")
    if node.gt_support is not None:
        add_face_to_node(faces.TextFace("GTsupport=%g" %(node.gt_support),
                                        fsize=8, fgcolor="black"), node, 1, position="branch-top")
    if node.nsupport_trees is not None:
        add_face_to_node(faces.TextFace("GTtrees=%d" %(node.nsupport_trees),
                                        fsize=8, fgcolor="grey"), node, 1, position="branch-top")
       
    if node.ntrees is not None:
        add_face_to_node(faces.TextFace("nTrees=%d" %(node.ntrees),
                                        fsize=8, fgcolor="green"), node, 1, position="branch-top")


    # Collateral info
    if node.coll_ndups is not None:
        add_face_to_node(faces.TextFace("Coll_Dups=%d(%0.2g dup/tree)" %(node.coll_ndups, node.coll_dup_rate),
                                        fsize=8, fgcolor="orange"), node, 2, position="branch-bottom")
    if node.coll_losses is not None:
        add_face_to_node(faces.TextFace("Coll_Losses=%d(%0.2g losses/tree)" %(node.coll_losses, node.coll_losses_rate),
                                   fsize=8, fgcolor="green"), node, 2, position="branch-bottom")

    if node.coll_nduplosses is not None:
        add_face_to_node(faces.TextFace("Coll_dupLosses=%d(%0.2g losses/tree)" %(node.coll_nduplosses, node.coll_duplosses_rate),
                                        fsize=8, fgcolor="blue"), node, 2, position="branch-bottom")
    if node.coll_gt_support is not None:
        add_face_to_node(faces.TextFace("Coll_GTsupport=%g" %(node.coll_gt_support),
                                        fsize=8, fgcolor="black"), node, 1, position="branch-top")
    if node.coll_nsupport_trees is not None:
        add_face_to_node(faces.TextFace("Coll_GTtrees=%d" %(node.coll_nsupport_trees),
                                        fsize=8, fgcolor="grey"), node, 1, position="branch-top")
    



        
def annotate_tree(reftree, informed_branches, dup_per_branch, losses_per_branch,
                  losses_per_dup_branch, refbranch_supports,
                  coll_dup_per_branch, coll_losses_per_branch,
                  coll_losses_per_dup_branch, coll_refbranch_supports):

    for refbranch in reftree.traverse():
        ntrees = informed_branches.get(refbranch, 0)
        dups = dup_per_branch.get(refbranch, [])
        ndups = len(dups) if ntrees else None
        dup_rate = ndups / float(ntrees) if ntrees else None
        losses = losses_per_branch.get(refbranch, 0) if ntrees else None
        losses_rate = losses / float(ntrees) if ntrees else None
        duplosses = losses_per_dup_branch.get(refbranch, [])
        nduplosses = len(duplosses) if ntrees else None
        duplosses_rate = nduplosses / float(ntrees) if ntrees else None
        all_supports = refbranch_supports.get(refbranch, None)
        gt_support = numpy.mean(all_supports) if all_supports else None
        nsupport_trees = len(all_supports) if all_supports else None
        
        refbranch.add_features(ntrees=ntrees, dups=dups, ndups=ndups, dup_rate=dup_rate,
                               losses=losses, losses_rate=losses_rate,
                               duplosses=duplosses,
                               nduplosses=nduplosses,
                               duplosses_rate=duplosses_rate,
                               gt_support=gt_support,
                               nsupport_trees=nsupport_trees)

        coll_dups = coll_dup_per_branch.get(refbranch, [])
        coll_ndups = len(coll_dups) if ntrees else None
        coll_dup_rate = coll_ndups / float(ntrees) if ntrees else None
        coll_losses = coll_losses_per_branch.get(refbranch, 0) if ntrees else None
        coll_losses_rate = coll_losses / float(ntrees) if ntrees else None
        coll_duplosses = coll_losses_per_dup_branch.get(refbranch, [])
        coll_nduplosses = len(coll_duplosses) if ntrees else None
        coll_duplosses_rate = coll_nduplosses / float(ntrees) if ntrees else None
        coll_all_supports = coll_refbranch_supports.get(refbranch, None)
        coll_gt_support = numpy.mean(coll_all_supports) if coll_all_supports else None
        coll_nsupport_trees = len(coll_all_supports) if coll_all_supports else None
       
        refbranch.add_features(coll_dups=coll_dups, coll_ndups=coll_ndups, coll_dup_rate=coll_dup_rate,
                               coll_losses=coll_losses, coll_losses_rate=coll_losses_rate, coll_duplosses=coll_duplosses,
                               coll_nduplosses=coll_nduplosses,
                               coll_duplosses_rate=coll_duplosses_rate,
                               coll_gt_support=coll_gt_support,
                               coll_nsupport_trees=coll_nsupport_trees)

        
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__DESCRIPTION__, 
                            formatter_class=argparse.RawDescriptionHelpFormatter)
    
    parser.add_argument("-r", dest="reftree", 
                        type=str, required=True,
                        help="""Reference tree""")

    parser.add_argument("--dups_file", dest="dups_file", 
                        type=str, 
                        help=("A file containing a list of precomputed duplication"
                              " events in the format:"
                              " TreeId [TAB] comma delimited left_content [TAB] comma delimited right content"))

    parser.add_argument("--spname_delimiter", dest="spname_delimiter", 
                        type=str, default="_",
                        help=(""))
    
    parser.add_argument("--spname_field", dest="spname_field", 
                        type=int, default=-1,
                        help=(""))

    parser.add_argument("--source_trees", dest="source_trees", 
                        type=str, 
                        help=(""))

    parser.add_argument("--collateral", dest="use_collateral", 
                        action="store_true",
                        help=("If enabled, collateral information will be used. Otherwise, only seed related information "))

    parser.add_argument("--detect_duplications", dest="detect_duplications", 
                        action="store_true",
                        help=(""))

    parser.add_argument("--debug", dest="debug", 
                        action="store_true",
                        help=("generates images of input trees, so the result can be inspected"))
        
    args = parser.parse_args()
    SPNAME_FIELD, SPNAME_DELIMITER = args.spname_field, args.spname_delimiter
    USE_COLLATERAL = args.use_collateral
    DETECT_DUPLICATIONS = args.detect_duplications
    MONITOR_STEP = 1000
    DEBUG = args.debug
    reftree = PhyloTree(args.reftree, sp_naming_function=None)
    
    data_iter = tree_iterator(args.source_trees, restrict_species=set(reftree.get_leaf_names()))
        
    (dup_per_branch, informed_branches, losses_per_branch,
     losses_per_dup_branch, refbranch_supports) = process_trees(data_iter, reftree)
    cPickle.dump(reftree, open("annotated_refTree.maptrees.pkl", "w"))
    
    
