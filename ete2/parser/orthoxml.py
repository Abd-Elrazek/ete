#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Sep 21 10:49:11 2010 by generateDS.py version 2.2a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class orthoXML(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, origin=None, version=None, originVersion=None, notes=None, species=None, scores=None, clusters=None):
        self.origin = _cast(None, origin)
        self.version = _cast(float, version)
        self.originVersion = _cast(float, originVersion)
        self.notes = notes
        if species is None:
            self.species = []
        else:
            self.species = species
        self.scores = scores
        self.clusters = clusters
    def factory(*args_, **kwargs_):
        if orthoXML.subclass:
            return orthoXML.subclass(*args_, **kwargs_)
        else:
            return orthoXML(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_species(self): return self.species
    def set_species(self, species): self.species = species
    def add_species(self, value): self.species.append(value)
    def insert_species(self, index, value): self.species[index] = value
    def get_scores(self): return self.scores
    def set_scores(self, scores): self.scores = scores
    def get_clusters(self): return self.clusters
    def set_clusters(self, clusters): self.clusters = clusters
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_originVersion(self): return self.originVersion
    def set_originVersion(self, originVersion): self.originVersion = originVersion
    def export(self, outfile, level, namespace_='', name_='orthoXML', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='orthoXML')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='orthoXML'):
        outfile.write(' origin=%s' % (self.gds_format_string(quote_attrib(self.origin).encode(ExternalEncoding), input_name='origin'), ))
        outfile.write(' version="%s"' % self.gds_format_float(self.version, input_name='version'))
        outfile.write(' originVersion="%s"' % self.gds_format_float(self.originVersion, input_name='originVersion'))
    def exportChildren(self, outfile, level, namespace_='', name_='orthoXML'):
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
        for species_ in self.species:
            species_.export(outfile, level, namespace_, name_='species')
        if self.scores:
            self.scores.export(outfile, level, namespace_, name_='scores', )
        if self.clusters:
            self.clusters.export(outfile, level, namespace_, name_='clusters', )
    def hasContent_(self):
        if (
            self.notes is not None or
            self.species or
            self.scores is not None or
            self.clusters is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='orthoXML'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin = "%s",\n' % (self.origin,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %f,\n' % (self.version,))
        if self.originVersion is not None:
            showIndent(outfile, level)
            outfile.write('originVersion = %f,\n' % (self.originVersion,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.notes(\n')
            self.notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('species=[\n')
        level += 1
        for species_ in self.species:
            showIndent(outfile, level)
            outfile.write('model_.species(\n')
            species_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.scores is not None:
            showIndent(outfile, level)
            outfile.write('scores=model_.scores(\n')
            self.scores.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.clusters is not None:
            showIndent(outfile, level)
            outfile.write('clusters=model_.clusters(\n')
            self.clusters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('origin')
        if value is not None:
            already_processed.append('origin')
            self.origin = value
        value = attrs.get('version')
        if value is not None:
            already_processed.append('version')
            try:
                self.version = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
        value = attrs.get('originVersion')
        if value is not None:
            already_processed.append('originVersion')
            try:
                self.originVersion = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (originVersion): %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'notes': 
            obj_ = notes.factory()
            obj_.build(child_)
            self.set_notes(obj_)
        elif nodeName_ == 'species': 
            obj_ = species.factory()
            obj_.build(child_)
            self.species.append(obj_)
        elif nodeName_ == 'scores': 
            obj_ = scores.factory()
            obj_.build(child_)
            self.set_scores(obj_)
        elif nodeName_ == 'clusters': 
            obj_ = clusters.factory()
            obj_.build(child_)
            self.set_clusters(obj_)
# end class orthoXML


class species(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, NCBITaxId=None, database=None, notes=None):
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.NCBITaxId = _cast(int, NCBITaxId)
        if database is None:
            self.database = []
        else:
            self.database = database
        self.notes = notes
    def factory(*args_, **kwargs_):
        if species.subclass:
            return species.subclass(*args_, **kwargs_)
        else:
            return species(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_database(self): return self.database
    def set_database(self, database): self.database = database
    def add_database(self, value): self.database.append(value)
    def insert_database(self, index, value): self.database[index] = value
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_NCBITaxId(self): return self.NCBITaxId
    def set_NCBITaxId(self, NCBITaxId): self.NCBITaxId = NCBITaxId
    def export(self, outfile, level, namespace_='', name_='species', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='species')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='species'):
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' NCBITaxId="%s"' % self.gds_format_integer(self.NCBITaxId, input_name='NCBITaxId'))
    def exportChildren(self, outfile, level, namespace_='', name_='species'):
        for database_ in self.database:
            database_.export(outfile, level, namespace_, name_='database')
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
    def hasContent_(self):
        if (
            self.database or
            self.notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='species'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.NCBITaxId is not None:
            showIndent(outfile, level)
            outfile.write('NCBITaxId = %d,\n' % (self.NCBITaxId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('database=[\n')
        level += 1
        for database_ in self.database:
            showIndent(outfile, level)
            outfile.write('model_.database(\n')
            database_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.notes(\n')
            self.notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
        value = attrs.get('NCBITaxId')
        if value is not None:
            already_processed.append('NCBITaxId')
            try:
                self.NCBITaxId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'database': 
            obj_ = database.factory()
            obj_.build(child_)
            self.database.append(obj_)
        elif nodeName_ == 'notes': 
            obj_ = notes.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class species


class database(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protLink=None, geneLink=None, name=None, version=None, genes=None):
        self.protLink = _cast(None, protLink)
        self.geneLink = _cast(None, geneLink)
        self.name = _cast(None, name)
        self.version = _cast(None, version)
        self.genes = genes
    def factory(*args_, **kwargs_):
        if database.subclass:
            return database.subclass(*args_, **kwargs_)
        else:
            return database(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genes(self): return self.genes
    def set_genes(self, genes): self.genes = genes
    def get_protLink(self): return self.protLink
    def set_protLink(self, protLink): self.protLink = protLink
    def get_geneLink(self): return self.geneLink
    def set_geneLink(self, geneLink): self.geneLink = geneLink
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='', name_='database', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='database')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='database'):
        if self.protLink is not None:
            outfile.write(' protLink=%s' % (self.gds_format_string(quote_attrib(self.protLink).encode(ExternalEncoding), input_name='protLink'), ))
        if self.geneLink is not None:
            outfile.write(' geneLink=%s' % (self.gds_format_string(quote_attrib(self.geneLink).encode(ExternalEncoding), input_name='geneLink'), ))
        outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='database'):
        if self.genes:
            self.genes.export(outfile, level, namespace_, name_='genes', )
    def hasContent_(self):
        if (
            self.genes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='database'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.protLink is not None:
            showIndent(outfile, level)
            outfile.write('protLink = "%s",\n' % (self.protLink,))
        if self.geneLink is not None:
            showIndent(outfile, level)
            outfile.write('geneLink = "%s",\n' % (self.geneLink,))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.genes is not None:
            showIndent(outfile, level)
            outfile.write('genes=model_.genes(\n')
            self.genes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('protLink')
        if value is not None:
            already_processed.append('protLink')
            self.protLink = value
        value = attrs.get('geneLink')
        if value is not None:
            already_processed.append('geneLink')
            self.geneLink = value
        value = attrs.get('name')
        if value is not None:
            already_processed.append('name')
            self.name = value
        value = attrs.get('version')
        if value is not None:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'genes': 
            obj_ = genes.factory()
            obj_.build(child_)
            self.set_genes(obj_)
# end class database


class genes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gene=None):
        if gene is None:
            self.gene = []
        else:
            self.gene = gene
    def factory(*args_, **kwargs_):
        if genes.subclass:
            return genes.subclass(*args_, **kwargs_)
        else:
            return genes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gene(self): return self.gene
    def set_gene(self, gene): self.gene = gene
    def add_gene(self, value): self.gene.append(value)
    def insert_gene(self, index, value): self.gene[index] = value
    def export(self, outfile, level, namespace_='', name_='genes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='genes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='genes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='genes'):
        for gene_ in self.gene:
            gene_.export(outfile, level, namespace_, name_='gene')
    def hasContent_(self):
        if (
            self.gene
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='genes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('gene=[\n')
        level += 1
        for gene_ in self.gene:
            showIndent(outfile, level)
            outfile.write('model_.gene(\n')
            gene_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'gene': 
            obj_ = gene.factory()
            obj_.build(child_)
            self.gene.append(obj_)
# end class genes


class gene(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protId=None, id=None, geneId=None, transcriptId=None, valueOf_=None):
        self.protId = _cast(None, protId)
        self.id = _cast(int, id)
        self.geneId = _cast(None, geneId)
        self.transcriptId = _cast(None, transcriptId)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if gene.subclass:
            return gene.subclass(*args_, **kwargs_)
        else:
            return gene(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protId(self): return self.protId
    def set_protId(self, protId): self.protId = protId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_geneId(self): return self.geneId
    def set_geneId(self, geneId): self.geneId = geneId
    def get_transcriptId(self): return self.transcriptId
    def set_transcriptId(self, transcriptId): self.transcriptId = transcriptId
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='gene', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='gene')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='gene'):
        outfile.write(' protId=%s' % (self.gds_format_string(quote_attrib(self.protId).encode(ExternalEncoding), input_name='protId'), ))
        outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        outfile.write(' geneId=%s' % (self.gds_format_string(quote_attrib(self.geneId).encode(ExternalEncoding), input_name='geneId'), ))
        if self.transcriptId is not None:
            outfile.write(' transcriptId=%s' % (self.gds_format_string(quote_attrib(self.transcriptId).encode(ExternalEncoding), input_name='transcriptId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='gene'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='gene'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.protId is not None:
            showIndent(outfile, level)
            outfile.write('protId = "%s",\n' % (self.protId,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.geneId is not None:
            showIndent(outfile, level)
            outfile.write('geneId = "%s",\n' % (self.geneId,))
        if self.transcriptId is not None:
            showIndent(outfile, level)
            outfile.write('transcriptId = "%s",\n' % (self.transcriptId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('protId')
        if value is not None:
            already_processed.append('protId')
            self.protId = value
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('geneId')
        if value is not None:
            already_processed.append('geneId')
            self.geneId = value
        value = attrs.get('transcriptId')
        if value is not None:
            already_processed.append('transcriptId')
            self.transcriptId = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class gene


class scores(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scoreDef=None):
        if scoreDef is None:
            self.scoreDef = []
        else:
            self.scoreDef = scoreDef
    def factory(*args_, **kwargs_):
        if scores.subclass:
            return scores.subclass(*args_, **kwargs_)
        else:
            return scores(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scoreDef(self): return self.scoreDef
    def set_scoreDef(self, scoreDef): self.scoreDef = scoreDef
    def add_scoreDef(self, value): self.scoreDef.append(value)
    def insert_scoreDef(self, index, value): self.scoreDef[index] = value
    def export(self, outfile, level, namespace_='', name_='scores', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='scores')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='scores'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='scores'):
        for scoreDef_ in self.scoreDef:
            scoreDef_.export(outfile, level, namespace_, name_='scoreDef')
    def hasContent_(self):
        if (
            self.scoreDef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scores'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('scoreDef=[\n')
        level += 1
        for scoreDef_ in self.scoreDef:
            showIndent(outfile, level)
            outfile.write('model_.scoreDef(\n')
            scoreDef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'scoreDef': 
            obj_ = scoreDef.factory()
            obj_.build(child_)
            self.scoreDef.append(obj_)
# end class scores


class clusters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cluster=None):
        if cluster is None:
            self.cluster = []
        else:
            self.cluster = cluster
    def factory(*args_, **kwargs_):
        if clusters.subclass:
            return clusters.subclass(*args_, **kwargs_)
        else:
            return clusters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cluster(self): return self.cluster
    def set_cluster(self, cluster): self.cluster = cluster
    def add_cluster(self, value): self.cluster.append(value)
    def insert_cluster(self, index, value): self.cluster[index] = value
    def export(self, outfile, level, namespace_='', name_='clusters', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='clusters')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='clusters'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='clusters'):
        for cluster_ in self.cluster:
            cluster_.export(outfile, level, namespace_, name_='cluster')
    def hasContent_(self):
        if (
            self.cluster
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='clusters'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cluster=[\n')
        level += 1
        for cluster_ in self.cluster:
            showIndent(outfile, level)
            outfile.write('model_.cluster(\n')
            cluster_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'cluster': 
            obj_ = cluster.factory()
            obj_.build(child_)
            self.cluster.append(obj_)
# end class clusters


class cluster(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, score=None, geneRef=None, notes=None):
        self.id = _cast(None, id)
        if score is None:
            self.score = []
        else:
            self.score = score
        if geneRef is None:
            self.geneRef = []
        else:
            self.geneRef = geneRef
        self.notes = notes
    def factory(*args_, **kwargs_):
        if cluster.subclass:
            return cluster.subclass(*args_, **kwargs_)
        else:
            return cluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def add_score(self, value): self.score.append(value)
    def insert_score(self, index, value): self.score[index] = value
    def get_geneRef(self): return self.geneRef
    def set_geneRef(self, geneRef): self.geneRef = geneRef
    def add_geneRef(self, value): self.geneRef.append(value)
    def insert_geneRef(self, index, value): self.geneRef[index] = value
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='cluster', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='cluster')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='cluster'):
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cluster'):
        for score_ in self.score:
            score_.export(outfile, level, namespace_, name_='score')
        for geneRef_ in self.geneRef:
            geneRef_.export(outfile, level, namespace_, name_='geneRef')
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
    def hasContent_(self):
        if (
            self.score or
            self.geneRef or
            self.notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cluster'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('score=[\n')
        level += 1
        for score_ in self.score:
            showIndent(outfile, level)
            outfile.write('model_.score(\n')
            score_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('geneRef=[\n')
        level += 1
        for geneRef_ in self.geneRef:
            showIndent(outfile, level)
            outfile.write('model_.geneRef(\n')
            geneRef_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.notes(\n')
            self.notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'score': 
            obj_ = score.factory()
            obj_.build(child_)
            self.score.append(obj_)
        elif nodeName_ == 'geneRef': 
            obj_ = geneRef.factory()
            obj_.build(child_)
            self.geneRef.append(obj_)
        elif nodeName_ == 'notes': 
            obj_ = notes.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class cluster


class geneRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, score=None, notes=None):
        self.id = _cast(int, id)
        if score is None:
            self.score = []
        else:
            self.score = score
        self.notes = notes
    def factory(*args_, **kwargs_):
        if geneRef.subclass:
            return geneRef.subclass(*args_, **kwargs_)
        else:
            return geneRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_score(self): return self.score
    def set_score(self, score): self.score = score
    def add_score(self, value): self.score.append(value)
    def insert_score(self, index, value): self.score[index] = value
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='geneRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='geneRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='geneRef'):
        outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='geneRef'):
        for score_ in self.score:
            score_.export(outfile, level, namespace_, name_='score')
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
    def hasContent_(self):
        if (
            self.score or
            self.notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='geneRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('score=[\n')
        level += 1
        for score_ in self.score:
            showIndent(outfile, level)
            outfile.write('model_.score(\n')
            score_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.notes(\n')
            self.notes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'score': 
            obj_ = score.factory()
            obj_.build(child_)
            self.score.append(obj_)
        elif nodeName_ == 'notes': 
            obj_ = notes.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class geneRef


class scoreDef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, desc=None, valueOf_=None):
        self.id = _cast(None, id)
        self.desc = _cast(None, desc)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if scoreDef.subclass:
            return scoreDef.subclass(*args_, **kwargs_)
        else:
            return scoreDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='scoreDef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='scoreDef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='scoreDef'):
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
        outfile.write(' desc=%s' % (self.gds_format_string(quote_attrib(self.desc).encode(ExternalEncoding), input_name='desc'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='scoreDef'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scoreDef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.desc is not None:
            showIndent(outfile, level)
            outfile.write('desc = "%s",\n' % (self.desc,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
        value = attrs.get('desc')
        if value is not None:
            already_processed.append('desc')
            self.desc = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class scoreDef


class score(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, valueOf_=None):
        self.id = _cast(None, id)
        self.value = _cast(float, value)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if score.subclass:
            return score.subclass(*args_, **kwargs_)
        else:
            return score(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='score', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='score')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='score'):
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
        outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='score'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='score'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value = %f,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
        value = attrs.get('value')
        if value is not None:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class score


class notes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if notes.subclass:
            return notes.subclass(*args_, **kwargs_)
        else:
            return notes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='notes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='notes')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='', name_='notes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='notes'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='notes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class notes


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'orthoXML'
        rootClass = orthoXML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    #sys.stdout.write('<?xml version="1.0" ?>\n')
    #rootObj.export(sys.stdout, 0, name_=rootTag, 
    #    namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'orthoXML'
        rootClass = orthoXML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="orthoXML",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'orthoXML'
        rootClass = orthoXML
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from orthoxml import *\n\n')
    sys.stdout.write('import orthoxml as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

