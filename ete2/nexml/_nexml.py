#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Thu Sep 23 19:16:39 2010 by generateDS.py version 2.2a.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class Base(GeneratedsSuper):
    """The base type for all complexType definitions in the nexml schema.
    This type allows a number of special attributes: xml:lang - for
    languages codes xml:base - see http://www.w3.org/TR/xmlbase/
    xml:id - see http://www.w3.org/TR/xml-id/ xml:space - for
    whitespace handling xlink:href - for links class - for class
    membership Also see http://www.w3.org/2001/xml.xsd for more
    information on the xml and xlink attributes."""
    subclass = None
    superclass = None
    def __init__(self, classxx=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.classxx = _cast(None, classxx)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Base.subclass:
            return Base.subclass(*args_, **kwargs_)
        else:
            return Base(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Base', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Base')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Base'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.classxx is not None:
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.classxx).encode(ExternalEncoding), input_name='class'), ))
        if self.id is not None:
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Base'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Base'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.classxx is not None:
            showIndent(outfile, level)
            outfile.write('classxx = "%s",\n' % (self.classxx,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('class')
        if value is not None:
            already_processed.append('class')
            self.classxx = value
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class Base


class Meta(Base):
    subclass = None
    superclass = Base
    def __init__(self, classxx=None, id=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Meta, self).__init__(classxx, id, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Meta.subclass:
            return Meta.subclass(*args_, **kwargs_)
        else:
            return Meta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Meta', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Meta')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Meta"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Meta'):
        super(Meta, self).exportAttributes(outfile, level, namespace_, name_='Meta')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Meta'):
        super(Meta, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Meta, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Meta'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(Meta, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Meta, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Meta, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Meta, self).buildChildren(child_, nodeName_, True)
        pass
# end class Meta


class ResourceMeta(Meta):
    """Metadata annotations in which the object is a resource. If this
    element contains meta elements as children, then the object of
    this annotation is a "blank node"."""
    subclass = None
    superclass = Meta
    def __init__(self, classxx=None, id=None, href=None, rel=None, meta=None, valueOf_=None, mixedclass_=None, content_=None):
        super(ResourceMeta, self).__init__(classxx, id, valueOf_, mixedclass_, content_, )
        self.href = _cast(None, href)
        self.rel = _cast(None, rel)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ResourceMeta.subclass:
            return ResourceMeta.subclass(*args_, **kwargs_)
        else:
            return ResourceMeta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ResourceMeta', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ResourceMeta')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="ResourceMeta"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ResourceMeta'):
        super(ResourceMeta, self).exportAttributes(outfile, level, namespace_, name_='ResourceMeta')
        if self.href is not None:
            outfile.write(' href=%s' % (quote_attrib(self.href), ))
        outfile.write(' rel=%s' % (quote_attrib(self.rel), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ResourceMeta'):
        super(ResourceMeta, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.meta or
            self.valueOf_ or
            super(ResourceMeta, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ResourceMeta'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.href is not None:
            showIndent(outfile, level)
            outfile.write('href = %s,\n' % (self.href,))
        if self.rel is not None:
            showIndent(outfile, level)
            outfile.write('rel = %s,\n' % (self.rel,))
        super(ResourceMeta, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceMeta, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('href')
        if value is not None:
            already_processed.append('href')
            self.href = value
        value = attrs.get('rel')
        if value is not None:
            already_processed.append('rel')
            self.rel = value
        super(ResourceMeta, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta':
            childobj_ = Meta.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'meta', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_meta'):
              self.add_meta(obj_.value)
            elif hasattr(self, 'set_meta'):
              self.set_meta(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(ResourceMeta, self).buildChildren(child_, nodeName_, True)
# end class ResourceMeta


class LiteralMeta(Meta):
    """Metadata annotations in which the object is a literal value. If the
    @content attribute is used, then the element should contain no
    children."""
    subclass = None
    superclass = Meta
    def __init__(self, classxx=None, id=None, datatype=None, content=None, property=None, valueOf_=None, mixedclass_=None, content_=None):
        super(LiteralMeta, self).__init__(classxx, id, valueOf_, mixedclass_, content_, )
        self.datatype = _cast(None, datatype)
        self.content = _cast(None, content)
        self.property = _cast(None, property)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LiteralMeta.subclass:
            return LiteralMeta.subclass(*args_, **kwargs_)
        else:
            return LiteralMeta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='LiteralMeta', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='LiteralMeta')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="LiteralMeta"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='LiteralMeta'):
        super(LiteralMeta, self).exportAttributes(outfile, level, namespace_, name_='LiteralMeta')
        if self.datatype is not None:
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.content is not None:
            outfile.write(' content=%s' % (self.gds_format_string(quote_attrib(self.content).encode(ExternalEncoding), input_name='content'), ))
        outfile.write(' property=%s' % (quote_attrib(self.property), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='LiteralMeta'):
        super(LiteralMeta, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(LiteralMeta, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='LiteralMeta'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.datatype is not None:
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content = "%s",\n' % (self.content,))
        if self.property is not None:
            showIndent(outfile, level)
            outfile.write('property = %s,\n' % (self.property,))
        super(LiteralMeta, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LiteralMeta, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('datatype')
        if value is not None:
            already_processed.append('datatype')
            self.datatype = value
        value = attrs.get('content')
        if value is not None:
            already_processed.append('content')
            self.content = value
        value = attrs.get('property')
        if value is not None:
            already_processed.append('property')
            self.property = value
        super(LiteralMeta, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(LiteralMeta, self).buildChildren(child_, nodeName_, True)
        pass
# end class LiteralMeta


class attrExtensions(GeneratedsSuper):
    """This element is for use in WSDL 1.1 only. It does not apply to WSDL
    2.0 documents. Use in WSDL 2.0 documents is invalid."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if attrExtensions.subclass:
            return attrExtensions.subclass(*args_, **kwargs_)
        else:
            return attrExtensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='attrExtensions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='attrExtensions')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='attrExtensions'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='attrExtensions'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='attrExtensions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class attrExtensions


class ContinuousChar(GeneratedsSuper):
    """A concrete implementation of the char element, which requires only
    an id attribute."""
    subclass = None
    superclass = None
    def __init__(self, states=None, tokens=None, codon=None, meta=None):
        self.states = _cast(None, states)
        self.tokens = _cast(None, tokens)
        self.codon = _cast(None, codon)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if ContinuousChar.subclass:
            return ContinuousChar.subclass(*args_, **kwargs_)
        else:
            return ContinuousChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousChar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousChar'):
        outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousChar'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class ContinuousChar


class ContinuousFormat(GeneratedsSuper):
    """The ContinuousFormat class is the container of continuous column
    definitions."""
    subclass = None
    superclass = None
    def __init__(self, char=None):
        if char is None:
            self.char = []
        else:
            self.char = char
    def factory(*args_, **kwargs_):
        if ContinuousFormat.subclass:
            return ContinuousFormat.subclass(*args_, **kwargs_)
        else:
            return ContinuousFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousFormat'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousFormat'):
        for char_ in self.char:
            char_.export(outfile, level, namespace_, name_='char')
    def hasContent_(self):
        if (
            self.char
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('char=[\n')
        level += 1
        for char_ in self.char:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousChar(\n')
            char_.exportLiteral(outfile, level, name_='ContinuousChar')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'char': 
            obj_ = ContinuousChar.factory()
            obj_.build(child_)
            self.char.append(obj_)
# end class ContinuousFormat


class ContinuousObs(GeneratedsSuper):
    """This is a single cell in a matrix containing a continuous
    observation."""
    subclass = None
    superclass = None
    def __init__(self, char=None, state=None, meta=None):
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if ContinuousObs.subclass:
            return ContinuousObs.subclass(*args_, **kwargs_)
        else:
            return ContinuousObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def validate_ContinuousToken(self, value):
        # Validate type ContinuousToken, a restriction on xs:float.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousObs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousObs'):
        outfile.write(' char=%s' % (self.gds_format_string(quote_attrib(self.char).encode(ExternalEncoding), input_name='char'), ))
        outfile.write(' state=%s' % (quote_attrib(self.state), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousObs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = "%s",\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = %f,\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
            self.validate_ContinuousToken(self.state)    # validate type ContinuousToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class ContinuousObs


class ContinuousMatrixSeqRow(GeneratedsSuper):
    """This is a row in a matrix of continuous data as character sequences."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, seq=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.seq = seq
    def factory(*args_, **kwargs_):
        if ContinuousMatrixSeqRow.subclass:
            return ContinuousMatrixSeqRow.subclass(*args_, **kwargs_)
        else:
            return ContinuousMatrixSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def validate_seq(self, value):
        # validate type seq
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousMatrixSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousMatrixSeqRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousMatrixSeqRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousMatrixSeqRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('<%sseq>%s</%sseq>\n' % (namespace_, self.gds_format_string(quote_xml(self.seq).encode(ExternalEncoding), input_name='seq'), namespace_))
    def hasContent_(self):
        if (
            self.meta or
            self.seq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousMatrixSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=%s,\n' % quote_python(self.seq).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'seq':
            seq_ = child_.text
            self.seq = seq_
            self.validate_seq(self.seq)    # validate type seq
# end class ContinuousMatrixSeqRow


class ContinuousMatrixObsRow(GeneratedsSuper):
    """This is a row in a matrix of continuous data as granular
    obervations."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, cell=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if ContinuousMatrixObsRow.subclass:
            return ContinuousMatrixObsRow.subclass(*args_, **kwargs_)
        else:
            return ContinuousMatrixObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousMatrixObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousMatrixObsRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousMatrixObsRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousMatrixObsRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.meta or
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousMatrixObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousObs(\n')
            cell_.exportLiteral(outfile, level, name_='ContinuousObs')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'cell': 
            obj_ = ContinuousObs.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class ContinuousMatrixObsRow


class ContinuousSeqMatrix(GeneratedsSuper):
    """A matrix of rows with seq strings of type continuous."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if ContinuousSeqMatrix.subclass:
            return ContinuousSeqMatrix.subclass(*args_, **kwargs_)
        else:
            return ContinuousSeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousSeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousSeqMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousSeqMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousSeqMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousSeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousMatrixSeqRow(\n')
            row_.exportLiteral(outfile, level, name_='ContinuousMatrixSeqRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = ContinuousMatrixSeqRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class ContinuousSeqMatrix


class ContinuousObsMatrix(GeneratedsSuper):
    """A matrix of rows with single character observations."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if ContinuousObsMatrix.subclass:
            return ContinuousObsMatrix.subclass(*args_, **kwargs_)
        else:
            return ContinuousObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousObsMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousObsMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousObsMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.ContinuousMatrixObsRow(\n')
            row_.exportLiteral(outfile, level, name_='ContinuousMatrixObsRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = ContinuousMatrixObsRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class ContinuousObsMatrix


class ContinuousSeqs(GeneratedsSuper):
    """A continuous characters block consisting of float sequences preceded
    by metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if ContinuousSeqs.subclass:
            return ContinuousSeqs.subclass(*args_, **kwargs_)
        else:
            return ContinuousSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousSeqs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousSeqs'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousSeqs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.ContinuousFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.ContinuousSeqMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = ContinuousFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = ContinuousSeqMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class ContinuousSeqs


class ContinuousCells(GeneratedsSuper):
    """A continuous characters block consisting of granular cells preceded
    by metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if ContinuousCells.subclass:
            return ContinuousCells.subclass(*args_, **kwargs_)
        else:
            return ContinuousCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ContinuousCells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousCells'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ContinuousCells'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ContinuousCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.ContinuousFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.ContinuousObsMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = ContinuousFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = ContinuousObsMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class ContinuousCells


class AbstractMapping(Base):
    """The AbstractMapping type is the superclass for an ambiguity mapping.
    In an instance document, a subclass of this type will look like
    <member state="st1"/>, i.e. an element called "member" with an
    attribute called "state" whose value is an id reference that
    refers to an element that subclasses AbstractState. The purpose
    of AbstractMapping is to specify which other states may be
    implied, e.g. a nucleotide symbol "N" would have mappings to
    "A", "C", "G" and "T"."""
    subclass = None
    superclass = Base
    def __init__(self, classxx=None, id=None, state=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractMapping, self).__init__(classxx, id, valueOf_, mixedclass_, content_, )
        self.state = _cast(None, state)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractMapping.subclass:
            return AbstractMapping.subclass(*args_, **kwargs_)
        else:
            return AbstractMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractMapping', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractMapping')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractMapping"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractMapping'):
        super(AbstractMapping, self).exportAttributes(outfile, level, namespace_, name_='AbstractMapping')
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractMapping'):
        super(AbstractMapping, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractMapping, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractMapping'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
        super(AbstractMapping, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractMapping, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
        super(AbstractMapping, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractMapping, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractMapping


class DNAMapping(GeneratedsSuper):
    """An IUPAC ambiguity mapping."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DNAMapping.subclass:
            return DNAMapping.subclass(*args_, **kwargs_)
        else:
            return DNAMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMapping', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAMapping')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMapping'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMapping'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAMapping'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class DNAMapping


class DNAState(GeneratedsSuper):
    """This is a concrete implementation of the state element, which
    requires a symbol element, in this case restricted to DNAToken,
    i.e. a single IUPAC nucleotide symbol, and optional mapping
    elements to refer to other states."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, valueOf_=None):
        self.symbol = _cast(None, symbol)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DNAState.subclass:
            return DNAState.subclass(*args_, **kwargs_)
        else:
            return DNAState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_DNAToken(self, value):
        # Validate type DNAToken, a restriction on AbstractSymbol.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAState')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAState'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAState'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_DNAToken(self.symbol)    # validate type DNAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class DNAState


class DNAUncertainStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
    def factory(*args_, **kwargs_):
        if DNAUncertainStateSet.subclass:
            return DNAUncertainStateSet.subclass(*args_, **kwargs_)
        else:
            return DNAUncertainStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_DNAToken(self, value):
        # Validate type DNAToken, a restriction on AbstractSymbol.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAUncertainStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAUncertainStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAUncertainStateSet'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAUncertainStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
    def hasContent_(self):
        if (
            self.member
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAUncertainStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.DNAMapping(\n')
            member_.exportLiteral(outfile, level, name_='DNAMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_DNAToken(self.symbol)    # validate type DNAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = DNAMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
# end class DNAUncertainStateSet


class DNAPolymorphicStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None, uncertain_state_set=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if DNAPolymorphicStateSet.subclass:
            return DNAPolymorphicStateSet.subclass(*args_, **kwargs_)
        else:
            return DNAPolymorphicStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_DNAToken(self, value):
        # Validate type DNAToken, a restriction on AbstractSymbol.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAPolymorphicStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAPolymorphicStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAPolymorphicStateSet'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAPolymorphicStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.member or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAPolymorphicStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.DNAMapping(\n')
            member_.exportLiteral(outfile, level, name_='DNAMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.DNAUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='DNAUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_DNAToken(self.symbol)    # validate type DNAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = DNAMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = DNAUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class DNAPolymorphicStateSet


class DNAStates(GeneratedsSuper):
    """A container for a set of states."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, state=None, polymorphic_state_set=None, uncertain_state_set=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if state is None:
            self.state = []
        else:
            self.state = state
        if polymorphic_state_set is None:
            self.polymorphic_state_set = []
        else:
            self.polymorphic_state_set = polymorphic_state_set
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if DNAStates.subclass:
            return DNAStates.subclass(*args_, **kwargs_)
        else:
            return DNAStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def get_polymorphic_state_set(self): return self.polymorphic_state_set
    def set_polymorphic_state_set(self, polymorphic_state_set): self.polymorphic_state_set = polymorphic_state_set
    def add_polymorphic_state_set(self, value): self.polymorphic_state_set.append(value)
    def insert_polymorphic_state_set(self, index, value): self.polymorphic_state_set[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAStates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAStates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAStates'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAStates'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
        for polymorphic_state_set_ in self.polymorphic_state_set:
            polymorphic_state_set_.export(outfile, level, namespace_, name_='polymorphic_state_set')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.meta or
            self.state or
            self.polymorphic_state_set or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAStates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.DNAState(\n')
            state_.exportLiteral(outfile, level, name_='DNAState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polymorphic_state_set=[\n')
        level += 1
        for polymorphic_state_set_ in self.polymorphic_state_set:
            showIndent(outfile, level)
            outfile.write('model_.DNAPolymorphicStateSet(\n')
            polymorphic_state_set_.exportLiteral(outfile, level, name_='DNAPolymorphicStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.DNAUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='DNAUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'state': 
            obj_ = DNAState.factory()
            obj_.build(child_)
            self.state.append(obj_)
        elif nodeName_ == 'polymorphic_state_set': 
            obj_ = DNAPolymorphicStateSet.factory()
            obj_.build(child_)
            self.polymorphic_state_set.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = DNAUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class DNAStates


class DNAChar(GeneratedsSuper):
    """A concrete implementation of the AbstractChar element. In this
    implementation there is no reference to explicitly defined
    states, as we use the IUPAC standard. There may be a
    CodonPosition ("codon") attribute, and there must be an
    identifier ("id") that is of type xs:nonNegativeInteger to
    define the column number."""
    subclass = None
    superclass = None
    def __init__(self, tokens=None, states=None, codon=None, id=None, meta=None):
        self.tokens = _cast(None, tokens)
        self.states = _cast(None, states)
        self.codon = _cast(None, codon)
        self.id = _cast(None, id)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if DNAChar.subclass:
            return DNAChar.subclass(*args_, **kwargs_)
        else:
            return DNAChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAChar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAChar'):
        outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        if self.codon is not None:
            outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAChar'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class DNAChar


class DNAFormat(GeneratedsSuper):
    """The DNAFormat class is the container of DNA column definitions."""
    subclass = None
    superclass = None
    def __init__(self, states=None, char=None):
        if states is None:
            self.states = []
        else:
            self.states = states
        if char is None:
            self.char = []
        else:
            self.char = char
    def factory(*args_, **kwargs_):
        if DNAFormat.subclass:
            return DNAFormat.subclass(*args_, **kwargs_)
        else:
            return DNAFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def add_states(self, value): self.states.append(value)
    def insert_states(self, index, value): self.states[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAFormat'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAFormat'):
        for states_ in self.states:
            states_.export(outfile, level, namespace_, name_='states')
        for char_ in self.char:
            char_.export(outfile, level, namespace_, name_='char')
    def hasContent_(self):
        if (
            self.states or
            self.char
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('states=[\n')
        level += 1
        for states_ in self.states:
            showIndent(outfile, level)
            outfile.write('model_.DNAStates(\n')
            states_.exportLiteral(outfile, level, name_='DNAStates')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('char=[\n')
        level += 1
        for char_ in self.char:
            showIndent(outfile, level)
            outfile.write('model_.DNAChar(\n')
            char_.exportLiteral(outfile, level, name_='DNAChar')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'states': 
            obj_ = DNAStates.factory()
            obj_.build(child_)
            self.states.append(obj_)
        elif nodeName_ == 'char': 
            obj_ = DNAChar.factory()
            obj_.build(child_)
            self.char.append(obj_)
# end class DNAFormat


class DNAObs(GeneratedsSuper):
    """This is a single cell in a matrix containing a nucleotide
    observation."""
    subclass = None
    superclass = None
    def __init__(self, char=None, state=None, meta=None):
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if DNAObs.subclass:
            return DNAObs.subclass(*args_, **kwargs_)
        else:
            return DNAObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAObs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAObs'):
        outfile.write(' char=%s' % (self.gds_format_string(quote_attrib(self.char).encode(ExternalEncoding), input_name='char'), ))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAObs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = "%s",\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class DNAObs


class DNAMatrixSeqRow(GeneratedsSuper):
    """This is a row in a matrix of DNA data containing raw sequence data."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, seq=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.seq = seq
    def factory(*args_, **kwargs_):
        if DNAMatrixSeqRow.subclass:
            return DNAMatrixSeqRow.subclass(*args_, **kwargs_)
        else:
            return DNAMatrixSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def validate_seq(self, value):
        # validate type seq
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMatrixSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAMatrixSeqRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMatrixSeqRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMatrixSeqRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('<%sseq>%s</%sseq>\n' % (namespace_, self.gds_format_string(quote_xml(self.seq).encode(ExternalEncoding), input_name='seq'), namespace_))
    def hasContent_(self):
        if (
            self.meta or
            self.seq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAMatrixSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=%s,\n' % quote_python(self.seq).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'seq':
            seq_ = child_.text
            self.seq = seq_
            self.validate_seq(self.seq)    # validate type seq
# end class DNAMatrixSeqRow


class DNAMatrixObsRow(GeneratedsSuper):
    """This is a row in a matrix of DNA data containing granular
    observations."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, cell=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if DNAMatrixObsRow.subclass:
            return DNAMatrixObsRow.subclass(*args_, **kwargs_)
        else:
            return DNAMatrixObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMatrixObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAMatrixObsRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMatrixObsRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAMatrixObsRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.meta or
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAMatrixObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.DNAObs(\n')
            cell_.exportLiteral(outfile, level, name_='DNAObs')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'cell': 
            obj_ = DNAObs.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class DNAMatrixObsRow


class DNASeqMatrix(GeneratedsSuper):
    """A matrix of rows with seq strings of type DNA."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if DNASeqMatrix.subclass:
            return DNASeqMatrix.subclass(*args_, **kwargs_)
        else:
            return DNASeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNASeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNASeqMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNASeqMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNASeqMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNASeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.DNAMatrixSeqRow(\n')
            row_.exportLiteral(outfile, level, name_='DNAMatrixSeqRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = DNAMatrixSeqRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class DNASeqMatrix


class DNAObsMatrix(GeneratedsSuper):
    """A matrix of rows with single character observations."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if DNAObsMatrix.subclass:
            return DNAObsMatrix.subclass(*args_, **kwargs_)
        else:
            return DNAObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DNAObsMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAObsMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DNAObsMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DNAObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.DNAMatrixObsRow(\n')
            row_.exportLiteral(outfile, level, name_='DNAMatrixObsRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = DNAMatrixObsRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class DNAObsMatrix


class DnaSeqs(GeneratedsSuper):
    """A DNA characters block consisting of sequences preceded by metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if DnaSeqs.subclass:
            return DnaSeqs.subclass(*args_, **kwargs_)
        else:
            return DnaSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DnaSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DnaSeqs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DnaSeqs'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DnaSeqs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DnaSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.DNAFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.DNASeqMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = DNAFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = DNASeqMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class DnaSeqs


class DnaCells(GeneratedsSuper):
    """A DNA characters block consisting of granular cells preceded by
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if DnaCells.subclass:
            return DnaCells.subclass(*args_, **kwargs_)
        else:
            return DnaCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='DnaCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DnaCells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='DnaCells'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='DnaCells'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='DnaCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.DNAFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.DNAObsMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = DNAFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = DNAObsMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class DnaCells


class AAChar(GeneratedsSuper):
    """A concrete implementation of the AbstractChar element. In this
    implementation there is no reference to explicitly defined
    states, as we use the IUPAC standard. There must be an
    identifier ("id") that is of type xs:nonNegativeInteger to
    define the column number."""
    subclass = None
    superclass = None
    def __init__(self, tokens=None, states=None, codon=None, id=None, meta=None):
        self.tokens = _cast(None, tokens)
        self.states = _cast(None, states)
        self.codon = _cast(None, codon)
        self.id = _cast(None, id)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if AAChar.subclass:
            return AAChar.subclass(*args_, **kwargs_)
        else:
            return AAChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAChar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAChar'):
        outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAChar'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class AAChar


class AAFormat(GeneratedsSuper):
    """The AAFormat class is the container of amino acid column
    definitions."""
    subclass = None
    superclass = None
    def __init__(self, states=None, char=None):
        if states is None:
            self.states = []
        else:
            self.states = states
        if char is None:
            self.char = []
        else:
            self.char = char
    def factory(*args_, **kwargs_):
        if AAFormat.subclass:
            return AAFormat.subclass(*args_, **kwargs_)
        else:
            return AAFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def add_states(self, value): self.states.append(value)
    def insert_states(self, index, value): self.states[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAFormat'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAFormat'):
        for states_ in self.states:
            states_.export(outfile, level, namespace_, name_='states')
        for char_ in self.char:
            char_.export(outfile, level, namespace_, name_='char')
    def hasContent_(self):
        if (
            self.states or
            self.char
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('states=[\n')
        level += 1
        for states_ in self.states:
            showIndent(outfile, level)
            outfile.write('model_.AAStates(\n')
            states_.exportLiteral(outfile, level, name_='AAStates')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('char=[\n')
        level += 1
        for char_ in self.char:
            showIndent(outfile, level)
            outfile.write('model_.AAChar(\n')
            char_.exportLiteral(outfile, level, name_='AAChar')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'states': 
            obj_ = AAStates.factory()
            obj_.build(child_)
            self.states.append(obj_)
        elif nodeName_ == 'char': 
            obj_ = AAChar.factory()
            obj_.build(child_)
            self.char.append(obj_)
# end class AAFormat


class AAStates(GeneratedsSuper):
    """A container for a set of states."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, state=None, polymorphic_state_set=None, uncertain_state_set=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if state is None:
            self.state = []
        else:
            self.state = state
        if polymorphic_state_set is None:
            self.polymorphic_state_set = []
        else:
            self.polymorphic_state_set = polymorphic_state_set
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if AAStates.subclass:
            return AAStates.subclass(*args_, **kwargs_)
        else:
            return AAStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def get_polymorphic_state_set(self): return self.polymorphic_state_set
    def set_polymorphic_state_set(self, polymorphic_state_set): self.polymorphic_state_set = polymorphic_state_set
    def add_polymorphic_state_set(self, value): self.polymorphic_state_set.append(value)
    def insert_polymorphic_state_set(self, index, value): self.polymorphic_state_set[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAStates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAStates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAStates'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAStates'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
        for polymorphic_state_set_ in self.polymorphic_state_set:
            polymorphic_state_set_.export(outfile, level, namespace_, name_='polymorphic_state_set')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.meta or
            self.state or
            self.polymorphic_state_set or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAStates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.AAState(\n')
            state_.exportLiteral(outfile, level, name_='AAState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polymorphic_state_set=[\n')
        level += 1
        for polymorphic_state_set_ in self.polymorphic_state_set:
            showIndent(outfile, level)
            outfile.write('model_.AAPolymorphicStateSet(\n')
            polymorphic_state_set_.exportLiteral(outfile, level, name_='AAPolymorphicStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.AAUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='AAUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'state': 
            obj_ = AAState.factory()
            obj_.build(child_)
            self.state.append(obj_)
        elif nodeName_ == 'polymorphic_state_set': 
            obj_ = AAPolymorphicStateSet.factory()
            obj_.build(child_)
            self.polymorphic_state_set.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = AAUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class AAStates


class AAPolymorphicStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None, uncertain_state_set=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if AAPolymorphicStateSet.subclass:
            return AAPolymorphicStateSet.subclass(*args_, **kwargs_)
        else:
            return AAPolymorphicStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_AAToken(self, value):
        # Validate type AAToken, a restriction on AbstractSymbol.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAPolymorphicStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAPolymorphicStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAPolymorphicStateSet'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAPolymorphicStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.member or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAPolymorphicStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.AAMapping(\n')
            member_.exportLiteral(outfile, level, name_='AAMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.AAUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='AAUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_AAToken(self.symbol)    # validate type AAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = AAMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = AAUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class AAPolymorphicStateSet


class AAUncertainStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
    def factory(*args_, **kwargs_):
        if AAUncertainStateSet.subclass:
            return AAUncertainStateSet.subclass(*args_, **kwargs_)
        else:
            return AAUncertainStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_AAToken(self, value):
        # Validate type AAToken, a restriction on AbstractSymbol.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAUncertainStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAUncertainStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAUncertainStateSet'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAUncertainStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
    def hasContent_(self):
        if (
            self.member
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAUncertainStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.AAMapping(\n')
            member_.exportLiteral(outfile, level, name_='AAMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_AAToken(self.symbol)    # validate type AAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = AAMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
# end class AAUncertainStateSet


class AAMapping(GeneratedsSuper):
    """An IUPAC ambiguity mapping."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AAMapping.subclass:
            return AAMapping.subclass(*args_, **kwargs_)
        else:
            return AAMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMapping', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAMapping')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMapping'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMapping'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAMapping'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class AAMapping


class AAState(GeneratedsSuper):
    """This is a concrete implementation of the state element, which
    requires a symbol element, in this case restricted to DNAToken,
    i.e. a single IUPAC nucleotide symbol, and optional mapping
    elements to refer to other states."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, valueOf_=None):
        self.symbol = _cast(None, symbol)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AAState.subclass:
            return AAState.subclass(*args_, **kwargs_)
        else:
            return AAState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_AAToken(self, value):
        # Validate type AAToken, a restriction on AbstractSymbol.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAState')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAState'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAState'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_AAToken(self.symbol)    # validate type AAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class AAState


class AAObs(GeneratedsSuper):
    """This is a single cell in a matrix containing an amino acid
    observation."""
    subclass = None
    superclass = None
    def __init__(self, char=None, state=None, meta=None):
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if AAObs.subclass:
            return AAObs.subclass(*args_, **kwargs_)
        else:
            return AAObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAObs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAObs'):
        outfile.write(' char=%s' % (self.gds_format_string(quote_attrib(self.char).encode(ExternalEncoding), input_name='char'), ))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAObs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = "%s",\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class AAObs


class AAMatrixSeqRow(GeneratedsSuper):
    """This is a row in a matrix of amino acid data containing raw sequence
    data."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, seq=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.seq = seq
    def factory(*args_, **kwargs_):
        if AAMatrixSeqRow.subclass:
            return AAMatrixSeqRow.subclass(*args_, **kwargs_)
        else:
            return AAMatrixSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def validate_seq(self, value):
        # validate type seq
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMatrixSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAMatrixSeqRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMatrixSeqRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMatrixSeqRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('<%sseq>%s</%sseq>\n' % (namespace_, self.gds_format_string(quote_xml(self.seq).encode(ExternalEncoding), input_name='seq'), namespace_))
    def hasContent_(self):
        if (
            self.meta or
            self.seq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAMatrixSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=%s,\n' % quote_python(self.seq).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'seq':
            seq_ = child_.text
            self.seq = seq_
            self.validate_seq(self.seq)    # validate type seq
# end class AAMatrixSeqRow


class AAMatrixObsRow(GeneratedsSuper):
    """This is a row in a matrix of amino acid data containing granular
    observations."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, cell=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if AAMatrixObsRow.subclass:
            return AAMatrixObsRow.subclass(*args_, **kwargs_)
        else:
            return AAMatrixObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMatrixObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAMatrixObsRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMatrixObsRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAMatrixObsRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.meta or
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAMatrixObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.AAObs(\n')
            cell_.exportLiteral(outfile, level, name_='AAObs')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'cell': 
            obj_ = AAObs.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class AAMatrixObsRow


class AASeqMatrix(GeneratedsSuper):
    """A matrix of rows with amino acid data as sequence strings."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if AASeqMatrix.subclass:
            return AASeqMatrix.subclass(*args_, **kwargs_)
        else:
            return AASeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AASeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AASeqMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AASeqMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AASeqMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AASeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.AAMatrixSeqRow(\n')
            row_.exportLiteral(outfile, level, name_='AAMatrixSeqRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = AAMatrixSeqRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class AASeqMatrix


class AAObsMatrix(GeneratedsSuper):
    """A matrix of rows with single character observations."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if AAObsMatrix.subclass:
            return AAObsMatrix.subclass(*args_, **kwargs_)
        else:
            return AAObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AAObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AAObsMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AAObsMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AAObsMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AAObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.AAMatrixObsRow(\n')
            row_.exportLiteral(outfile, level, name_='AAMatrixObsRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = AAMatrixObsRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class AAObsMatrix


class ProteinSeqs(GeneratedsSuper):
    """An amino acid characters block consisting of sequences preceded by
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if ProteinSeqs.subclass:
            return ProteinSeqs.subclass(*args_, **kwargs_)
        else:
            return ProteinSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ProteinSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ProteinSeqs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ProteinSeqs'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ProteinSeqs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ProteinSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.AAFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.AASeqMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = AAFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = AASeqMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class ProteinSeqs


class ProteinCells(GeneratedsSuper):
    """An amino acid characters block consisting of granular cells preceded
    by metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if ProteinCells.subclass:
            return ProteinCells.subclass(*args_, **kwargs_)
        else:
            return ProteinCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='ProteinCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ProteinCells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='ProteinCells'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='ProteinCells'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='ProteinCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.AAFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.AAObsMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = AAFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = AAObsMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class ProteinCells


class RestrictionState(GeneratedsSuper):
    """This is a concrete implementation of the state element, which
    requires a symbol element, in this case restricted to integers,
    and optional mapping elements to refer to other states."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, valueOf_=None):
        self.symbol = _cast(None, symbol)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RestrictionState.subclass:
            return RestrictionState.subclass(*args_, **kwargs_)
        else:
            return RestrictionState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_RestrictionToken(self, value):
        # Validate type RestrictionToken, a restriction on xs:integer.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionState')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionState'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionState'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %d,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_RestrictionToken(self.symbol)    # validate type RestrictionToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class RestrictionState


class RestrictionStates(GeneratedsSuper):
    """A container for a set of states."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, state=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if RestrictionStates.subclass:
            return RestrictionStates.subclass(*args_, **kwargs_)
        else:
            return RestrictionStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionStates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionStates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionStates'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionStates'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.meta or
            self.state
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionStates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionState(\n')
            state_.exportLiteral(outfile, level, name_='RestrictionState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'state': 
            obj_ = RestrictionState.factory()
            obj_.build(child_)
            self.state.append(obj_)
# end class RestrictionStates


class RestrictionChar(GeneratedsSuper):
    """A concrete implementation of the char element, which only requires a
    unique identifier."""
    subclass = None
    superclass = None
    def __init__(self, tokens=None, states=None, codon=None, id=None, meta=None):
        self.tokens = _cast(None, tokens)
        self.states = _cast(None, states)
        self.codon = _cast(None, codon)
        self.id = _cast(None, id)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if RestrictionChar.subclass:
            return RestrictionChar.subclass(*args_, **kwargs_)
        else:
            return RestrictionChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionChar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionChar'):
        outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionChar'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class RestrictionChar


class RestrictionFormat(GeneratedsSuper):
    """The RestrictionFormat class is the container of restriction column
    definitions."""
    subclass = None
    superclass = None
    def __init__(self, states=None, char=None):
        if states is None:
            self.states = []
        else:
            self.states = states
        if char is None:
            self.char = []
        else:
            self.char = char
    def factory(*args_, **kwargs_):
        if RestrictionFormat.subclass:
            return RestrictionFormat.subclass(*args_, **kwargs_)
        else:
            return RestrictionFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def add_states(self, value): self.states.append(value)
    def insert_states(self, index, value): self.states[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionFormat'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionFormat'):
        for states_ in self.states:
            states_.export(outfile, level, namespace_, name_='states')
        for char_ in self.char:
            char_.export(outfile, level, namespace_, name_='char')
    def hasContent_(self):
        if (
            self.states or
            self.char
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('states=[\n')
        level += 1
        for states_ in self.states:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionStates(\n')
            states_.exportLiteral(outfile, level, name_='RestrictionStates')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('char=[\n')
        level += 1
        for char_ in self.char:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionChar(\n')
            char_.exportLiteral(outfile, level, name_='RestrictionChar')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'states': 
            obj_ = RestrictionStates.factory()
            obj_.build(child_)
            self.states.append(obj_)
        elif nodeName_ == 'char': 
            obj_ = RestrictionChar.factory()
            obj_.build(child_)
            self.char.append(obj_)
# end class RestrictionFormat


class RestrictionObs(GeneratedsSuper):
    """This is a single cell in a matrix containing a restriction site
    observation."""
    subclass = None
    superclass = None
    def __init__(self, char=None, state=None, meta=None):
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if RestrictionObs.subclass:
            return RestrictionObs.subclass(*args_, **kwargs_)
        else:
            return RestrictionObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionObs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionObs'):
        outfile.write(' char=%s' % (self.gds_format_string(quote_attrib(self.char).encode(ExternalEncoding), input_name='char'), ))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionObs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = "%s",\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class RestrictionObs


class RestrictionMatrixSeqRow(GeneratedsSuper):
    """This is a row in a matrix of restriction site data as character
    sequences."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, seq=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.seq = seq
    def factory(*args_, **kwargs_):
        if RestrictionMatrixSeqRow.subclass:
            return RestrictionMatrixSeqRow.subclass(*args_, **kwargs_)
        else:
            return RestrictionMatrixSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def validate_seq(self, value):
        # validate type seq
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionMatrixSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionMatrixSeqRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionMatrixSeqRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionMatrixSeqRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('<%sseq>%s</%sseq>\n' % (namespace_, self.gds_format_string(quote_xml(self.seq).encode(ExternalEncoding), input_name='seq'), namespace_))
    def hasContent_(self):
        if (
            self.meta or
            self.seq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionMatrixSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=%s,\n' % quote_python(self.seq).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'seq':
            seq_ = child_.text
            self.seq = seq_
            self.validate_seq(self.seq)    # validate type seq
# end class RestrictionMatrixSeqRow


class RestrictionMatrixObsRow(GeneratedsSuper):
    """This is a row in a matrix of restriction site data as granular
    obervations."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, cell=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if RestrictionMatrixObsRow.subclass:
            return RestrictionMatrixObsRow.subclass(*args_, **kwargs_)
        else:
            return RestrictionMatrixObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionMatrixObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionMatrixObsRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionMatrixObsRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionMatrixObsRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.meta or
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionMatrixObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionObs(\n')
            cell_.exportLiteral(outfile, level, name_='RestrictionObs')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'cell': 
            obj_ = RestrictionObs.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class RestrictionMatrixObsRow


class RestrictionSeqMatrix(GeneratedsSuper):
    """A matrix of rows with seq strings of type restriction."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if RestrictionSeqMatrix.subclass:
            return RestrictionSeqMatrix.subclass(*args_, **kwargs_)
        else:
            return RestrictionSeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionSeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionSeqMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionSeqMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionSeqMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionSeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionMatrixSeqRow(\n')
            row_.exportLiteral(outfile, level, name_='RestrictionMatrixSeqRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = RestrictionMatrixSeqRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class RestrictionSeqMatrix


class RestrictionObsMatrix(GeneratedsSuper):
    """A matrix of rows with single character observations."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if RestrictionObsMatrix.subclass:
            return RestrictionObsMatrix.subclass(*args_, **kwargs_)
        else:
            return RestrictionObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionObsMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionObsMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionObsMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionMatrixObsRow(\n')
            row_.exportLiteral(outfile, level, name_='RestrictionMatrixObsRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = RestrictionMatrixObsRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class RestrictionObsMatrix


class RestrictionSeqs(GeneratedsSuper):
    """A restriction site characters block consisting of sequences preceded
    by metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if RestrictionSeqs.subclass:
            return RestrictionSeqs.subclass(*args_, **kwargs_)
        else:
            return RestrictionSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionSeqs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionSeqs'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionSeqs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.RestrictionFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.RestrictionSeqMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = RestrictionFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = RestrictionSeqMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class RestrictionSeqs


class RestrictionCells(GeneratedsSuper):
    """A standard characters block consisting of granular cells preceded by
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if RestrictionCells.subclass:
            return RestrictionCells.subclass(*args_, **kwargs_)
        else:
            return RestrictionCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionCells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionCells'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RestrictionCells'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RestrictionCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.RestrictionFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.RestrictionObsMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = RestrictionFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = RestrictionObsMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class RestrictionCells


class RNAMapping(GeneratedsSuper):
    """An IUPAC ambiguity mapping."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RNAMapping.subclass:
            return RNAMapping.subclass(*args_, **kwargs_)
        else:
            return RNAMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMapping', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAMapping')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMapping'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMapping'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAMapping'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class RNAMapping


class RNAState(GeneratedsSuper):
    """This is a concrete implementation of the state element, which
    requires a symbol element, in this case restricted to RNAToken,
    i.e. a single IUPAC nucleotide symbol, and optional mapping
    elements to refer to other states."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, valueOf_=None):
        self.symbol = _cast(None, symbol)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RNAState.subclass:
            return RNAState.subclass(*args_, **kwargs_)
        else:
            return RNAState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_RNAToken(self, value):
        # Validate type RNAToken, a restriction on AbstractSymbol.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAState')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAState'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAState'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_RNAToken(self.symbol)    # validate type RNAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class RNAState


class RNAUncertainStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
    def factory(*args_, **kwargs_):
        if RNAUncertainStateSet.subclass:
            return RNAUncertainStateSet.subclass(*args_, **kwargs_)
        else:
            return RNAUncertainStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_RNAToken(self, value):
        # Validate type RNAToken, a restriction on AbstractSymbol.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAUncertainStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAUncertainStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAUncertainStateSet'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAUncertainStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
    def hasContent_(self):
        if (
            self.member
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAUncertainStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.RNAMapping(\n')
            member_.exportLiteral(outfile, level, name_='RNAMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_RNAToken(self.symbol)    # validate type RNAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = RNAMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
# end class RNAUncertainStateSet


class RNAPolymorphicStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None, uncertain_state_set=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if RNAPolymorphicStateSet.subclass:
            return RNAPolymorphicStateSet.subclass(*args_, **kwargs_)
        else:
            return RNAPolymorphicStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_RNAToken(self, value):
        # Validate type RNAToken, a restriction on AbstractSymbol.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAPolymorphicStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAPolymorphicStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAPolymorphicStateSet'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAPolymorphicStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.member or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAPolymorphicStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.RNAMapping(\n')
            member_.exportLiteral(outfile, level, name_='RNAMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.RNAUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='RNAUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_RNAToken(self.symbol)    # validate type RNAToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = RNAMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = RNAUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class RNAPolymorphicStateSet


class RNAStates(GeneratedsSuper):
    """A container for a set of states."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, state=None, polymorphic_state_set=None, uncertain_state_set=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if state is None:
            self.state = []
        else:
            self.state = state
        if polymorphic_state_set is None:
            self.polymorphic_state_set = []
        else:
            self.polymorphic_state_set = polymorphic_state_set
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if RNAStates.subclass:
            return RNAStates.subclass(*args_, **kwargs_)
        else:
            return RNAStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def get_polymorphic_state_set(self): return self.polymorphic_state_set
    def set_polymorphic_state_set(self, polymorphic_state_set): self.polymorphic_state_set = polymorphic_state_set
    def add_polymorphic_state_set(self, value): self.polymorphic_state_set.append(value)
    def insert_polymorphic_state_set(self, index, value): self.polymorphic_state_set[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAStates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAStates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAStates'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAStates'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
        for polymorphic_state_set_ in self.polymorphic_state_set:
            polymorphic_state_set_.export(outfile, level, namespace_, name_='polymorphic_state_set')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.meta or
            self.state or
            self.polymorphic_state_set or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAStates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.RNAState(\n')
            state_.exportLiteral(outfile, level, name_='RNAState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polymorphic_state_set=[\n')
        level += 1
        for polymorphic_state_set_ in self.polymorphic_state_set:
            showIndent(outfile, level)
            outfile.write('model_.RNAPolymorphicStateSet(\n')
            polymorphic_state_set_.exportLiteral(outfile, level, name_='RNAPolymorphicStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.RNAUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='RNAUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'state': 
            obj_ = RNAState.factory()
            obj_.build(child_)
            self.state.append(obj_)
        elif nodeName_ == 'polymorphic_state_set': 
            obj_ = RNAPolymorphicStateSet.factory()
            obj_.build(child_)
            self.polymorphic_state_set.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = RNAUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class RNAStates


class RNAChar(GeneratedsSuper):
    """A concrete implementation of the AbstractChar element. In this
    implementation there is no reference to explicitly defined
    states, as we use the IUPAC standard. There may be a
    CodonPosition ("codon") attribute, and there must be an
    identifier ("id") that is of type xs:nonNegativeInteger to
    define the column number."""
    subclass = None
    superclass = None
    def __init__(self, tokens=None, states=None, codon=None, id=None, meta=None):
        self.tokens = _cast(None, tokens)
        self.states = _cast(None, states)
        self.codon = _cast(None, codon)
        self.id = _cast(None, id)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if RNAChar.subclass:
            return RNAChar.subclass(*args_, **kwargs_)
        else:
            return RNAChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAChar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAChar'):
        outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        if self.codon is not None:
            outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAChar'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class RNAChar


class RNAFormat(GeneratedsSuper):
    """The RNAFormat class is the container of RNA column definitions."""
    subclass = None
    superclass = None
    def __init__(self, states=None, char=None):
        if states is None:
            self.states = []
        else:
            self.states = states
        if char is None:
            self.char = []
        else:
            self.char = char
    def factory(*args_, **kwargs_):
        if RNAFormat.subclass:
            return RNAFormat.subclass(*args_, **kwargs_)
        else:
            return RNAFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def add_states(self, value): self.states.append(value)
    def insert_states(self, index, value): self.states[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAFormat'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAFormat'):
        for states_ in self.states:
            states_.export(outfile, level, namespace_, name_='states')
        for char_ in self.char:
            char_.export(outfile, level, namespace_, name_='char')
    def hasContent_(self):
        if (
            self.states or
            self.char
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('states=[\n')
        level += 1
        for states_ in self.states:
            showIndent(outfile, level)
            outfile.write('model_.RNAStates(\n')
            states_.exportLiteral(outfile, level, name_='RNAStates')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('char=[\n')
        level += 1
        for char_ in self.char:
            showIndent(outfile, level)
            outfile.write('model_.RNAChar(\n')
            char_.exportLiteral(outfile, level, name_='RNAChar')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'states': 
            obj_ = RNAStates.factory()
            obj_.build(child_)
            self.states.append(obj_)
        elif nodeName_ == 'char': 
            obj_ = RNAChar.factory()
            obj_.build(child_)
            self.char.append(obj_)
# end class RNAFormat


class RNAObs(GeneratedsSuper):
    """This is a single cell in a matrix containing a nucleotide
    observation."""
    subclass = None
    superclass = None
    def __init__(self, char=None, state=None, meta=None):
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if RNAObs.subclass:
            return RNAObs.subclass(*args_, **kwargs_)
        else:
            return RNAObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAObs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAObs'):
        outfile.write(' char=%s' % (self.gds_format_string(quote_attrib(self.char).encode(ExternalEncoding), input_name='char'), ))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAObs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = "%s",\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class RNAObs


class RNAMatrixSeqRow(GeneratedsSuper):
    """This is a row in a matrix of RNA data containing raw sequence data."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, seq=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.seq = seq
    def factory(*args_, **kwargs_):
        if RNAMatrixSeqRow.subclass:
            return RNAMatrixSeqRow.subclass(*args_, **kwargs_)
        else:
            return RNAMatrixSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def validate_seq(self, value):
        # validate type seq
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMatrixSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAMatrixSeqRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMatrixSeqRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMatrixSeqRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('<%sseq>%s</%sseq>\n' % (namespace_, self.gds_format_string(quote_xml(self.seq).encode(ExternalEncoding), input_name='seq'), namespace_))
    def hasContent_(self):
        if (
            self.meta or
            self.seq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAMatrixSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=%s,\n' % quote_python(self.seq).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'seq':
            seq_ = child_.text
            self.seq = seq_
            self.validate_seq(self.seq)    # validate type seq
# end class RNAMatrixSeqRow


class RNAMatrixObsRow(GeneratedsSuper):
    """This is a row in a matrix of RNA data containing granular
    observations."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, cell=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if RNAMatrixObsRow.subclass:
            return RNAMatrixObsRow.subclass(*args_, **kwargs_)
        else:
            return RNAMatrixObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMatrixObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAMatrixObsRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMatrixObsRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAMatrixObsRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.meta or
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAMatrixObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.RNAObs(\n')
            cell_.exportLiteral(outfile, level, name_='RNAObs')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'cell': 
            obj_ = RNAObs.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class RNAMatrixObsRow


class RNASeqMatrix(GeneratedsSuper):
    """A matrix of rows with seq strings of type RNA."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if RNASeqMatrix.subclass:
            return RNASeqMatrix.subclass(*args_, **kwargs_)
        else:
            return RNASeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNASeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNASeqMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNASeqMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNASeqMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNASeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.RNAMatrixSeqRow(\n')
            row_.exportLiteral(outfile, level, name_='RNAMatrixSeqRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = RNAMatrixSeqRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class RNASeqMatrix


class RNAObsMatrix(GeneratedsSuper):
    """A matrix of rows with single character observations."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if RNAObsMatrix.subclass:
            return RNAObsMatrix.subclass(*args_, **kwargs_)
        else:
            return RNAObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RNAObsMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAObsMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RNAObsMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RNAObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.RNAMatrixObsRow(\n')
            row_.exportLiteral(outfile, level, name_='RNAMatrixObsRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = RNAMatrixObsRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class RNAObsMatrix


class RnaSeqs(GeneratedsSuper):
    """A RNA characters block consisting of sequences preceded by metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if RnaSeqs.subclass:
            return RnaSeqs.subclass(*args_, **kwargs_)
        else:
            return RnaSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RnaSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RnaSeqs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RnaSeqs'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RnaSeqs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RnaSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.RNAFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.RNASeqMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = RNAFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = RNASeqMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class RnaSeqs


class RnaCells(GeneratedsSuper):
    """A RNA characters block consisting of granular cells preceded by
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if RnaCells.subclass:
            return RnaCells.subclass(*args_, **kwargs_)
        else:
            return RnaCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='RnaCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RnaCells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='RnaCells'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='RnaCells'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format')
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='RnaCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.RNAFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.RNAObsMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = RNAFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = RNAObsMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class RnaCells


class StandardMapping(GeneratedsSuper):
    """A standard character ambiguity mapping."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if StandardMapping.subclass:
            return StandardMapping.subclass(*args_, **kwargs_)
        else:
            return StandardMapping(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMapping', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardMapping')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMapping'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMapping'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardMapping'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class StandardMapping


class StandardState(GeneratedsSuper):
    """This is a concrete implementation of the state element, which
    requires a symbol element, in this case restricted to integers,
    and optional mapping elements to refer to other states."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, meta=None):
        self.symbol = _cast(None, symbol)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if StandardState.subclass:
            return StandardState.subclass(*args_, **kwargs_)
        else:
            return StandardState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def validate_StandardToken(self, value):
        # Validate type StandardToken, a restriction on xs:integer.
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardState')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardState'):
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardState'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %d,\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
            self.validate_StandardToken(self.symbol)    # validate type StandardToken
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class StandardState


class StandardUncertainStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, symbol=None, member=None):
        self.symbol = _cast(None, symbol)
        if member is None:
            self.member = []
        else:
            self.member = member
    def factory(*args_, **kwargs_):
        if StandardUncertainStateSet.subclass:
            return StandardUncertainStateSet.subclass(*args_, **kwargs_)
        else:
            return StandardUncertainStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardUncertainStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardUncertainStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardUncertainStateSet'):
        outfile.write(' symbol=%s' % (self.gds_format_string(quote_attrib(self.symbol).encode(ExternalEncoding), input_name='symbol'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardUncertainStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
    def hasContent_(self):
        if (
            self.member
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardUncertainStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = "%s",\n' % (self.symbol,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.StandardMapping(\n')
            member_.exportLiteral(outfile, level, name_='StandardMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = StandardMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
# end class StandardUncertainStateSet


class StandardPolymorphicStateSet(GeneratedsSuper):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = None
    def __init__(self, member=None, uncertain_state_set=None):
        if member is None:
            self.member = []
        else:
            self.member = member
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if StandardPolymorphicStateSet.subclass:
            return StandardPolymorphicStateSet.subclass(*args_, **kwargs_)
        else:
            return StandardPolymorphicStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardPolymorphicStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardPolymorphicStateSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardPolymorphicStateSet'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardPolymorphicStateSet'):
        for member_ in self.member:
            member_.export(outfile, level, namespace_, name_='member')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.member or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardPolymorphicStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('member=[\n')
        level += 1
        for member_ in self.member:
            showIndent(outfile, level)
            outfile.write('model_.StandardMapping(\n')
            member_.exportLiteral(outfile, level, name_='StandardMapping')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.StandardUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='StandardUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member': 
            obj_ = StandardMapping.factory()
            obj_.build(child_)
            self.member.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = StandardUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class StandardPolymorphicStateSet


class StandardStates(GeneratedsSuper):
    """A container for a set of states."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, state=None, polymorphic_state_set=None, uncertain_state_set=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if state is None:
            self.state = []
        else:
            self.state = state
        if polymorphic_state_set is None:
            self.polymorphic_state_set = []
        else:
            self.polymorphic_state_set = polymorphic_state_set
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
    def factory(*args_, **kwargs_):
        if StandardStates.subclass:
            return StandardStates.subclass(*args_, **kwargs_)
        else:
            return StandardStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def get_polymorphic_state_set(self): return self.polymorphic_state_set
    def set_polymorphic_state_set(self, polymorphic_state_set): self.polymorphic_state_set = polymorphic_state_set
    def add_polymorphic_state_set(self, value): self.polymorphic_state_set.append(value)
    def insert_polymorphic_state_set(self, index, value): self.polymorphic_state_set[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardStates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardStates')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardStates'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardStates'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
        for polymorphic_state_set_ in self.polymorphic_state_set:
            polymorphic_state_set_.export(outfile, level, namespace_, name_='polymorphic_state_set')
        for uncertain_state_set_ in self.uncertain_state_set:
            uncertain_state_set_.export(outfile, level, namespace_, name_='uncertain_state_set')
    def hasContent_(self):
        if (
            self.meta or
            self.state or
            self.polymorphic_state_set or
            self.uncertain_state_set
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardStates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StandardState(\n')
            state_.exportLiteral(outfile, level, name_='StandardState')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('polymorphic_state_set=[\n')
        level += 1
        for polymorphic_state_set_ in self.polymorphic_state_set:
            showIndent(outfile, level)
            outfile.write('model_.StandardPolymorphicStateSet(\n')
            polymorphic_state_set_.exportLiteral(outfile, level, name_='StandardPolymorphicStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uncertain_state_set=[\n')
        level += 1
        for uncertain_state_set_ in self.uncertain_state_set:
            showIndent(outfile, level)
            outfile.write('model_.StandardUncertainStateSet(\n')
            uncertain_state_set_.exportLiteral(outfile, level, name_='StandardUncertainStateSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'state': 
            obj_ = StandardState.factory()
            obj_.build(child_)
            self.state.append(obj_)
        elif nodeName_ == 'polymorphic_state_set': 
            obj_ = StandardPolymorphicStateSet.factory()
            obj_.build(child_)
            self.polymorphic_state_set.append(obj_)
        elif nodeName_ == 'uncertain_state_set': 
            obj_ = StandardUncertainStateSet.factory()
            obj_.build(child_)
            self.uncertain_state_set.append(obj_)
# end class StandardStates


class StandardChar(GeneratedsSuper):
    """A concrete implementation of the char element, which requires a
    states attribute to refer to a set of defined states"""
    subclass = None
    superclass = None
    def __init__(self, tokens=None, states=None, codon=None, id=None, meta=None):
        self.tokens = _cast(None, tokens)
        self.states = _cast(None, states)
        self.codon = _cast(None, codon)
        self.id = _cast(None, id)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if StandardChar.subclass:
            return StandardChar.subclass(*args_, **kwargs_)
        else:
            return StandardChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardChar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardChar'):
        outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
        outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardChar'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
        value = attrs.get('id')
        if value is not None:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class StandardChar


class StandardFormat(GeneratedsSuper):
    """The StandardFormat class is the container of standard column
    definitions."""
    subclass = None
    superclass = None
    def __init__(self, states=None, char=None):
        if states is None:
            self.states = []
        else:
            self.states = states
        if char is None:
            self.char = []
        else:
            self.char = char
    def factory(*args_, **kwargs_):
        if StandardFormat.subclass:
            return StandardFormat.subclass(*args_, **kwargs_)
        else:
            return StandardFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def add_states(self, value): self.states.append(value)
    def insert_states(self, index, value): self.states[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardFormat')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardFormat'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardFormat'):
        for states_ in self.states:
            states_.export(outfile, level, namespace_, name_='states')
        for char_ in self.char:
            char_.export(outfile, level, namespace_, name_='char')
    def hasContent_(self):
        if (
            self.states or
            self.char
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('states=[\n')
        level += 1
        for states_ in self.states:
            showIndent(outfile, level)
            outfile.write('model_.StandardStates(\n')
            states_.exportLiteral(outfile, level, name_='StandardStates')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('char=[\n')
        level += 1
        for char_ in self.char:
            showIndent(outfile, level)
            outfile.write('model_.StandardChar(\n')
            char_.exportLiteral(outfile, level, name_='StandardChar')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'states': 
            obj_ = StandardStates.factory()
            obj_.build(child_)
            self.states.append(obj_)
        elif nodeName_ == 'char': 
            obj_ = StandardChar.factory()
            obj_.build(child_)
            self.char.append(obj_)
# end class StandardFormat


class StandardObs(GeneratedsSuper):
    """This is a single cell in a matrix containing a standard observation."""
    subclass = None
    superclass = None
    def __init__(self, char=None, state=None, meta=None):
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if StandardObs.subclass:
            return StandardObs.subclass(*args_, **kwargs_)
        else:
            return StandardObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardObs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardObs'):
        outfile.write(' char=%s' % (self.gds_format_string(quote_attrib(self.char).encode(ExternalEncoding), input_name='char'), ))
        outfile.write(' state=%s' % (self.gds_format_string(quote_attrib(self.state).encode(ExternalEncoding), input_name='state'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardObs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = "%s",\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = "%s",\n' % (self.state,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class StandardObs


class StandardMatrixSeqRow(GeneratedsSuper):
    """This is a row in a matrix of standard data as character sequences."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, seq=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.seq = seq
    def factory(*args_, **kwargs_):
        if StandardMatrixSeqRow.subclass:
            return StandardMatrixSeqRow.subclass(*args_, **kwargs_)
        else:
            return StandardMatrixSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def validate_seq(self, value):
        # validate type seq
        pass
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMatrixSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardMatrixSeqRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMatrixSeqRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMatrixSeqRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('<%sseq>%s</%sseq>\n' % (namespace_, self.gds_format_string(quote_xml(self.seq).encode(ExternalEncoding), input_name='seq'), namespace_))
    def hasContent_(self):
        if (
            self.meta or
            self.seq is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardMatrixSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.seq is not None:
            showIndent(outfile, level)
            outfile.write('seq=%s,\n' % quote_python(self.seq).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'seq':
            seq_ = child_.text
            self.seq = seq_
            self.validate_seq(self.seq)    # validate type seq
# end class StandardMatrixSeqRow


class StandardMatrixObsRow(GeneratedsSuper):
    """This is a row in a matrix of standard data as granular obervations."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, cell=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
    def factory(*args_, **kwargs_):
        if StandardMatrixObsRow.subclass:
            return StandardMatrixObsRow.subclass(*args_, **kwargs_)
        else:
            return StandardMatrixObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMatrixObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardMatrixObsRow')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMatrixObsRow'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardMatrixObsRow'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for cell_ in self.cell:
            cell_.export(outfile, level, namespace_, name_='cell')
    def hasContent_(self):
        if (
            self.meta or
            self.cell
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardMatrixObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cell=[\n')
        level += 1
        for cell_ in self.cell:
            showIndent(outfile, level)
            outfile.write('model_.StandardObs(\n')
            cell_.exportLiteral(outfile, level, name_='StandardObs')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'cell': 
            obj_ = StandardObs.factory()
            obj_.build(child_)
            self.cell.append(obj_)
# end class StandardMatrixObsRow


class StandardSeqMatrix(GeneratedsSuper):
    """A matrix of rows with seq strings of type standard."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if StandardSeqMatrix.subclass:
            return StandardSeqMatrix.subclass(*args_, **kwargs_)
        else:
            return StandardSeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardSeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardSeqMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardSeqMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardSeqMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardSeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.StandardMatrixSeqRow(\n')
            row_.exportLiteral(outfile, level, name_='StandardMatrixSeqRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = StandardMatrixSeqRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class StandardSeqMatrix


class StandardObsMatrix(GeneratedsSuper):
    """A matrix of rows with single character observations."""
    subclass = None
    superclass = None
    def __init__(self, row=None):
        if row is None:
            self.row = []
        else:
            self.row = row
    def factory(*args_, **kwargs_):
        if StandardObsMatrix.subclass:
            return StandardObsMatrix.subclass(*args_, **kwargs_)
        else:
            return StandardObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardObsMatrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardObsMatrix'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardObsMatrix'):
        for row_ in self.row:
            row_.export(outfile, level, namespace_, name_='row')
    def hasContent_(self):
        if (
            self.row
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('row=[\n')
        level += 1
        for row_ in self.row:
            showIndent(outfile, level)
            outfile.write('model_.StandardMatrixObsRow(\n')
            row_.exportLiteral(outfile, level, name_='StandardMatrixObsRow')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row': 
            obj_ = StandardMatrixObsRow.factory()
            obj_.build(child_)
            self.row.append(obj_)
# end class StandardObsMatrix


class StandardSeqs(GeneratedsSuper):
    """A standard characters block consisting of sequences preceded by
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if StandardSeqs.subclass:
            return StandardSeqs.subclass(*args_, **kwargs_)
        else:
            return StandardSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardSeqs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardSeqs'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardSeqs'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.StandardFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.StandardSeqMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = StandardFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = StandardSeqMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class StandardSeqs


class StandardCells(GeneratedsSuper):
    """A standard characters block consisting of granular cells preceded by
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, format=None, matrix=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.format = format
        self.matrix = matrix
    def factory(*args_, **kwargs_):
        if StandardCells.subclass:
            return StandardCells.subclass(*args_, **kwargs_)
        else:
            return StandardCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StandardCells')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardCells'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='StandardCells'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        if self.format:
            self.format.export(outfile, level, namespace_, name_='format', )
        if self.matrix:
            self.matrix.export(outfile, level, namespace_, name_='matrix', )
    def hasContent_(self):
        if (
            self.meta or
            self.format is not None or
            self.matrix is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='StandardCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.format is not None:
            showIndent(outfile, level)
            outfile.write('format=model_.StandardFormat(\n')
            self.format.exportLiteral(outfile, level, name_='format')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.matrix is not None:
            showIndent(outfile, level)
            outfile.write('matrix=model_.StandardObsMatrix(\n')
            self.matrix.exportLiteral(outfile, level, name_='matrix')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'format': 
            obj_ = StandardFormat.factory()
            obj_.build(child_)
            self.set_format(obj_)
        elif nodeName_ == 'matrix': 
            obj_ = StandardObsMatrix.factory()
            obj_.build(child_)
            self.set_matrix(obj_)
# end class StandardCells


class TreeNode(GeneratedsSuper):
    """A concrete node implementation."""
    subclass = None
    superclass = None
    def __init__(self, meta=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if TreeNode.subclass:
            return TreeNode.subclass(*args_, **kwargs_)
        else:
            return TreeNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeNode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TreeNode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeNode'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeNode'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TreeNode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class TreeNode


class TreeFloatEdge(GeneratedsSuper):
    """A concrete edge implementation, with float length."""
    subclass = None
    superclass = None
    def __init__(self, length=None, meta=None):
        self.length = _cast(float, length)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if TreeFloatEdge.subclass:
            return TreeFloatEdge.subclass(*args_, **kwargs_)
        else:
            return TreeFloatEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeFloatEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TreeFloatEdge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeFloatEdge'):
        if self.length is not None:
            outfile.write(' length="%s"' % self.gds_format_float(self.length, input_name='length'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeFloatEdge'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TreeFloatEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %f,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            try:
                self.length = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class TreeFloatEdge


class TreeFloatRootEdge(GeneratedsSuper):
    """A concrete root edge implementation, with float length."""
    subclass = None
    superclass = None
    def __init__(self, length=None, meta=None):
        self.length = _cast(float, length)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if TreeFloatRootEdge.subclass:
            return TreeFloatRootEdge.subclass(*args_, **kwargs_)
        else:
            return TreeFloatRootEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeFloatRootEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TreeFloatRootEdge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeFloatRootEdge'):
        if self.length is not None:
            outfile.write(' length="%s"' % self.gds_format_float(self.length, input_name='length'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeFloatRootEdge'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TreeFloatRootEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %f,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            try:
                self.length = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class TreeFloatRootEdge


class TreeIntEdge(GeneratedsSuper):
    """A concrete edge implementation, with int length."""
    subclass = None
    superclass = None
    def __init__(self, length=None, meta=None):
        self.length = _cast(int, length)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if TreeIntEdge.subclass:
            return TreeIntEdge.subclass(*args_, **kwargs_)
        else:
            return TreeIntEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeIntEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TreeIntEdge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeIntEdge'):
        if self.length is not None:
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeIntEdge'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TreeIntEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %d,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            try:
                self.length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class TreeIntEdge


class TreeIntRootEdge(GeneratedsSuper):
    """A concrete root edge implementation, with int length."""
    subclass = None
    superclass = None
    def __init__(self, length=None, meta=None):
        self.length = _cast(int, length)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if TreeIntRootEdge.subclass:
            return TreeIntRootEdge.subclass(*args_, **kwargs_)
        else:
            return TreeIntRootEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeIntRootEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TreeIntRootEdge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeIntRootEdge'):
        if self.length is not None:
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TreeIntRootEdge'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TreeIntRootEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %d,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            try:
                self.length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class TreeIntRootEdge


class FloatTree(GeneratedsSuper):
    """A concrete tree implementation, with floating point edge lengths."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, node=None, rootedge=None, edge=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if node is None:
            self.node = []
        else:
            self.node = node
        self.rootedge = rootedge
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
    def factory(*args_, **kwargs_):
        if FloatTree.subclass:
            return FloatTree.subclass(*args_, **kwargs_)
        else:
            return FloatTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_rootedge(self): return self.rootedge
    def set_rootedge(self, rootedge): self.rootedge = rootedge
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='FloatTree', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FloatTree')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='FloatTree'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='FloatTree'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for node_ in self.node:
            node_.export(outfile, level, namespace_, name_='node')
        if self.rootedge:
            self.rootedge.export(outfile, level, namespace_, name_='rootedge')
        for edge_ in self.edge:
            edge_.export(outfile, level, namespace_, name_='edge')
    def hasContent_(self):
        if (
            self.meta or
            self.node or
            self.rootedge is not None or
            self.edge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='FloatTree'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('node=[\n')
        level += 1
        for node_ in self.node:
            showIndent(outfile, level)
            outfile.write('model_.TreeNode(\n')
            node_.exportLiteral(outfile, level, name_='TreeNode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.rootedge is not None:
            showIndent(outfile, level)
            outfile.write('rootedge=model_.TreeFloatRootEdge(\n')
            self.rootedge.exportLiteral(outfile, level, name_='rootedge')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('edge=[\n')
        level += 1
        for edge_ in self.edge:
            showIndent(outfile, level)
            outfile.write('model_.TreeFloatEdge(\n')
            edge_.exportLiteral(outfile, level, name_='TreeFloatEdge')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'node': 
            obj_ = TreeNode.factory()
            obj_.build(child_)
            self.node.append(obj_)
        elif nodeName_ == 'rootedge': 
            obj_ = TreeFloatRootEdge.factory()
            obj_.build(child_)
            self.set_rootedge(obj_)
        elif nodeName_ == 'edge': 
            obj_ = TreeFloatEdge.factory()
            obj_.build(child_)
            self.edge.append(obj_)
# end class FloatTree


class IntTree(GeneratedsSuper):
    """A concrete tree implementation, with integer edge lengths."""
    subclass = None
    superclass = None
    def __init__(self, meta=None, node=None, rootedge=None, edge=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        if node is None:
            self.node = []
        else:
            self.node = node
        self.rootedge = rootedge
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
    def factory(*args_, **kwargs_):
        if IntTree.subclass:
            return IntTree.subclass(*args_, **kwargs_)
        else:
            return IntTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_rootedge(self): return self.rootedge
    def set_rootedge(self, rootedge): self.rootedge = rootedge
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='IntTree', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='IntTree')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='IntTree'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='IntTree'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
        for node_ in self.node:
            node_.export(outfile, level, namespace_, name_='node')
        if self.rootedge:
            self.rootedge.export(outfile, level, namespace_, name_='rootedge')
        for edge_ in self.edge:
            edge_.export(outfile, level, namespace_, name_='edge')
    def hasContent_(self):
        if (
            self.meta or
            self.node or
            self.rootedge is not None or
            self.edge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='IntTree'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('node=[\n')
        level += 1
        for node_ in self.node:
            showIndent(outfile, level)
            outfile.write('model_.TreeNode(\n')
            node_.exportLiteral(outfile, level, name_='TreeNode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.rootedge is not None:
            showIndent(outfile, level)
            outfile.write('rootedge=model_.TreeIntRootEdge(\n')
            self.rootedge.exportLiteral(outfile, level, name_='rootedge')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('edge=[\n')
        level += 1
        for edge_ in self.edge:
            showIndent(outfile, level)
            outfile.write('model_.TreeIntEdge(\n')
            edge_.exportLiteral(outfile, level, name_='TreeIntEdge')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
        elif nodeName_ == 'node': 
            obj_ = TreeNode.factory()
            obj_.build(child_)
            self.node.append(obj_)
        elif nodeName_ == 'rootedge': 
            obj_ = TreeIntRootEdge.factory()
            obj_.build(child_)
            self.set_rootedge(obj_)
        elif nodeName_ == 'edge': 
            obj_ = TreeIntEdge.factory()
            obj_.build(child_)
            self.edge.append(obj_)
# end class IntTree


class NetworkNode(GeneratedsSuper):
    """A concrete network node implementation."""
    subclass = None
    superclass = None
    def __init__(self, meta=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if NetworkNode.subclass:
            return NetworkNode.subclass(*args_, **kwargs_)
        else:
            return NetworkNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkNode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkNode')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkNode'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkNode'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='NetworkNode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class NetworkNode


class NetworkFloatEdge(GeneratedsSuper):
    """A concrete network edge implementation, with float edge."""
    subclass = None
    superclass = None
    def __init__(self, length=None, meta=None):
        self.length = _cast(float, length)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if NetworkFloatEdge.subclass:
            return NetworkFloatEdge.subclass(*args_, **kwargs_)
        else:
            return NetworkFloatEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkFloatEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkFloatEdge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkFloatEdge'):
        if self.length is not None:
            outfile.write(' length="%s"' % self.gds_format_float(self.length, input_name='length'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkFloatEdge'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='NetworkFloatEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %f,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            try:
                self.length = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class NetworkFloatEdge


class NetworkIntEdge(GeneratedsSuper):
    """A concrete network edge implementation, with int edge."""
    subclass = None
    superclass = None
    def __init__(self, length=None, meta=None):
        self.length = _cast(int, length)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if NetworkIntEdge.subclass:
            return NetworkIntEdge.subclass(*args_, **kwargs_)
        else:
            return NetworkIntEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkIntEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NetworkIntEdge')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkIntEdge'):
        if self.length is not None:
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='NetworkIntEdge'):
        for meta_ in self.get_meta():
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='NetworkIntEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %d,\n' % (self.length,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.Meta(\n')
            meta_.exportLiteral(outfile, level, name_='Meta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            try:
                self.length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <meta> element')
            self.meta.append(obj_)
# end class NetworkIntEdge


class FloatNetwork(GeneratedsSuper):
    """A concrete network implementation, with floating point edge lengths."""
    subclass = None
    superclass = None
    def __init__(self, node=None, edge=None):
        if node is None:
            self.node = []
        else:
            self.node = node
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
    def factory(*args_, **kwargs_):
        if FloatNetwork.subclass:
            return FloatNetwork.subclass(*args_, **kwargs_)
        else:
            return FloatNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='FloatNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FloatNetwork')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='FloatNetwork'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='FloatNetwork'):
        for node_ in self.node:
            node_.export(outfile, level, namespace_, name_='node')
        for edge_ in self.edge:
            edge_.export(outfile, level, namespace_, name_='edge')
    def hasContent_(self):
        if (
            self.node or
            self.edge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='FloatNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('node=[\n')
        level += 1
        for node_ in self.node:
            showIndent(outfile, level)
            outfile.write('model_.NetworkNode(\n')
            node_.exportLiteral(outfile, level, name_='NetworkNode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('edge=[\n')
        level += 1
        for edge_ in self.edge:
            showIndent(outfile, level)
            outfile.write('model_.NetworkFloatEdge(\n')
            edge_.exportLiteral(outfile, level, name_='NetworkFloatEdge')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'node': 
            obj_ = NetworkNode.factory()
            obj_.build(child_)
            self.node.append(obj_)
        elif nodeName_ == 'edge': 
            obj_ = NetworkFloatEdge.factory()
            obj_.build(child_)
            self.edge.append(obj_)
# end class FloatNetwork


class IntNetwork(GeneratedsSuper):
    """A concrete network implementation, with integer edge lengths."""
    subclass = None
    superclass = None
    def __init__(self, node=None, edge=None):
        if node is None:
            self.node = []
        else:
            self.node = node
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
    def factory(*args_, **kwargs_):
        if IntNetwork.subclass:
            return IntNetwork.subclass(*args_, **kwargs_)
        else:
            return IntNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='IntNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='IntNetwork')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='IntNetwork'):
        pass
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='IntNetwork'):
        for node_ in self.node:
            node_.export(outfile, level, namespace_, name_='node')
        for edge_ in self.edge:
            edge_.export(outfile, level, namespace_, name_='edge')
    def hasContent_(self):
        if (
            self.node or
            self.edge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='IntNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('node=[\n')
        level += 1
        for node_ in self.node:
            showIndent(outfile, level)
            outfile.write('model_.NetworkNode(\n')
            node_.exportLiteral(outfile, level, name_='NetworkNode')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('edge=[\n')
        level += 1
        for edge_ in self.edge:
            showIndent(outfile, level)
            outfile.write('model_.NetworkIntEdge(\n')
            edge_.exportLiteral(outfile, level, name_='NetworkIntEdge')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'node': 
            obj_ = NetworkNode.factory()
            obj_.build(child_)
            self.node.append(obj_)
        elif nodeName_ == 'edge': 
            obj_ = NetworkIntEdge.factory()
            obj_.build(child_)
            self.edge.append(obj_)
# end class IntNetwork


class Annotated(Base):
    """The Annotated complexType is a super class for objects that
    optionally have metadata annotations of type Meta."""
    subclass = None
    superclass = Base
    def __init__(self, classxx=None, id=None, about=None, meta=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Annotated, self).__init__(classxx, id, valueOf_, mixedclass_, content_, )
        self.about = _cast(None, about)
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Annotated.subclass:
            return Annotated.subclass(*args_, **kwargs_)
        else:
            return Annotated(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def get_about(self): return self.about
    def set_about(self, about): self.about = about
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Annotated', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Annotated')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Annotated"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Annotated'):
        super(Annotated, self).exportAttributes(outfile, level, namespace_, name_='Annotated')
        if self.about is not None:
            outfile.write(' about=%s' % (quote_attrib(self.about), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Annotated'):
        super(Annotated, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.meta or
            self.valueOf_ or
            super(Annotated, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Annotated'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.about is not None:
            showIndent(outfile, level)
            outfile.write('about = %s,\n' % (self.about,))
        super(Annotated, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Annotated, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('about')
        if value is not None:
            already_processed.append('about')
            self.about = value
        super(Annotated, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'meta':
            childobj_ = Meta.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'meta', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_meta'):
              self.add_meta(obj_.value)
            elif hasattr(self, 'set_meta'):
              self.set_meta(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Annotated, self).buildChildren(child_, nodeName_, True)
# end class Annotated


class Nexml(Annotated):
    """The root element for nexml."""
    subclass = None
    superclass = Annotated
    def __init__(self, classxx=None, id=None, about=None, meta=None, version=None, generator=None, otus=None, characters=None, trees=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Nexml, self).__init__(classxx, id, about, meta, valueOf_, mixedclass_, content_, )
        self.version = _cast(None, version)
        self.generator = _cast(None, generator)
        if otus is None:
            self.otus = []
        else:
            self.otus = otus
        if characters is None:
            self.characters = []
        else:
            self.characters = characters
        if trees is None:
            self.trees = []
        else:
            self.trees = trees
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Nexml.subclass:
            return Nexml.subclass(*args_, **kwargs_)
        else:
            return Nexml(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otus(self): return self.otus
    def set_otus(self, otus): self.otus = otus
    def add_otus(self, value): self.otus.append(value)
    def insert_otus(self, index, value): self.otus[index] = value
    def get_characters(self): return self.characters
    def set_characters(self, characters): self.characters = characters
    def add_characters(self, value): self.characters.append(value)
    def insert_characters(self, index, value): self.characters[index] = value
    def get_trees(self): return self.trees
    def set_trees(self, trees): self.trees = trees
    def add_trees(self, value): self.trees.append(value)
    def insert_trees(self, index, value): self.trees[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_Nexml1_0(self, value):
        # Validate type Nexml1_0, a restriction on xs:decimal.
        pass
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Nexml', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Nexml')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Nexml"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Nexml'):
        super(Nexml, self).exportAttributes(outfile, level, namespace_, name_='Nexml')
        outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.generator is not None:
            outfile.write(' generator=%s' % (self.gds_format_string(quote_attrib(self.generator).encode(ExternalEncoding), input_name='generator'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Nexml'):
        super(Nexml, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.otus or
            self.characters or
            self.trees or
            self.valueOf_ or
            super(Nexml, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Nexml'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %f,\n' % (self.version,))
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator = "%s",\n' % (self.generator,))
        super(Nexml, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Nexml, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('version')
        if value is not None:
            already_processed.append('version')
            self.version = value
            self.validate_Nexml1_0(self.version)    # validate type Nexml1_0
        value = attrs.get('generator')
        if value is not None:
            already_processed.append('generator')
            self.generator = value
        super(Nexml, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'otus':
            childobj_ = Taxa.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'otus', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_otus'):
              self.add_otus(obj_.value)
            elif hasattr(self, 'set_otus'):
              self.set_otus(obj_.value)
        elif nodeName_ == 'characters':
            childobj_ = AbstractBlock.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'characters', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_characters'):
              self.add_characters(obj_.value)
            elif hasattr(self, 'set_characters'):
              self.set_characters(obj_.value)
        elif nodeName_ == 'trees':
            childobj_ = Trees.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'trees', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_trees'):
              self.add_trees(obj_.value)
            elif hasattr(self, 'set_trees'):
              self.set_trees(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Nexml, self).buildChildren(child_, nodeName_, True)
# end class Nexml


class AbstractObsMatrix(Annotated):
    """The AbstractObsMatrix super class is the abstract type for a
    <matrix> element that contains rows which hold granular state
    observations."""
    subclass = None
    superclass = Annotated
    def __init__(self, classxx=None, id=None, about=None, meta=None, row=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractObsMatrix, self).__init__(classxx, id, about, meta, valueOf_, mixedclass_, content_, )
        if row is None:
            self.row = []
        else:
            self.row = row
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractObsMatrix.subclass:
            return AbstractObsMatrix.subclass(*args_, **kwargs_)
        else:
            return AbstractObsMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObsMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractObsMatrix')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractObsMatrix"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObsMatrix'):
        super(AbstractObsMatrix, self).exportAttributes(outfile, level, namespace_, name_='AbstractObsMatrix')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObsMatrix'):
        super(AbstractObsMatrix, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.row or
            self.valueOf_ or
            super(AbstractObsMatrix, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractObsMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractObsMatrix, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractObsMatrix, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractObsMatrix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row':
            childobj_ = AbstractObsRow.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'row', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_row'):
              self.add_row(obj_.value)
            elif hasattr(self, 'set_row'):
              self.set_row(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractObsMatrix, self).buildChildren(child_, nodeName_, True)
# end class AbstractObsMatrix


class AbstractSeqMatrix(Annotated):
    """The AbstractSeqMatrix super class is the abstract type for a
    <matrix> element that contains rows which hold raw character
    sequences."""
    subclass = None
    superclass = Annotated
    def __init__(self, classxx=None, id=None, about=None, meta=None, row=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractSeqMatrix, self).__init__(classxx, id, about, meta, valueOf_, mixedclass_, content_, )
        if row is None:
            self.row = []
        else:
            self.row = row
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractSeqMatrix.subclass:
            return AbstractSeqMatrix.subclass(*args_, **kwargs_)
        else:
            return AbstractSeqMatrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def add_row(self, value): self.row.append(value)
    def insert_row(self, index, value): self.row[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqMatrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractSeqMatrix')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractSeqMatrix"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqMatrix'):
        super(AbstractSeqMatrix, self).exportAttributes(outfile, level, namespace_, name_='AbstractSeqMatrix')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqMatrix'):
        super(AbstractSeqMatrix, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.row or
            self.valueOf_ or
            super(AbstractSeqMatrix, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractSeqMatrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractSeqMatrix, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractSeqMatrix, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractSeqMatrix, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'row':
            childobj_ = AbstractSeqRow.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'row', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_row'):
              self.add_row(obj_.value)
            elif hasattr(self, 'set_row'):
              self.set_row(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractSeqMatrix, self).buildChildren(child_, nodeName_, True)
# end class AbstractSeqMatrix


class AbstractFormat(Annotated):
    """The AbstractFormat type is the superclass for the element that
    defines the allowed characters and states in a matrix, and their
    ambiguity mapping. It may enclose AbstractStates elements that
    define states and their mappings, and AbstractChar elements that
    specify which AbstractStates apply to which matrix columns."""
    subclass = None
    superclass = Annotated
    def __init__(self, classxx=None, id=None, about=None, meta=None, states=None, char=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractFormat, self).__init__(classxx, id, about, meta, valueOf_, mixedclass_, content_, )
        if states is None:
            self.states = []
        else:
            self.states = states
        if char is None:
            self.char = []
        else:
            self.char = char
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractFormat.subclass:
            return AbstractFormat.subclass(*args_, **kwargs_)
        else:
            return AbstractFormat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def add_states(self, value): self.states.append(value)
    def insert_states(self, index, value): self.states[index] = value
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def add_char(self, value): self.char.append(value)
    def insert_char(self, index, value): self.char[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractFormat', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractFormat')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractFormat"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractFormat'):
        super(AbstractFormat, self).exportAttributes(outfile, level, namespace_, name_='AbstractFormat')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractFormat'):
        super(AbstractFormat, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.states or
            self.char or
            self.valueOf_ or
            super(AbstractFormat, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractFormat'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractFormat, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractFormat, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractFormat, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'states':
            childobj_ = AbstractStates.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'states', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_states'):
              self.add_states(obj_.value)
            elif hasattr(self, 'set_states'):
              self.set_states(obj_.value)
        elif nodeName_ == 'char':
            childobj_ = AbstractChar.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'char', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_char'):
              self.add_char(obj_.value)
            elif hasattr(self, 'set_char'):
              self.set_char(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractFormat, self).buildChildren(child_, nodeName_, True)
# end class AbstractFormat


class Labelled(Annotated):
    """The Labelled complexType is a super class for objects that
    optionally have label attributes to use as a (non-unique) name
    of type xs:string."""
    subclass = None
    superclass = Annotated
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Labelled, self).__init__(classxx, id, about, meta, valueOf_, mixedclass_, content_, )
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Labelled.subclass:
            return Labelled.subclass(*args_, **kwargs_)
        else:
            return Labelled(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Labelled', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Labelled')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Labelled"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Labelled'):
        super(Labelled, self).exportAttributes(outfile, level, namespace_, name_='Labelled')
        if self.label is not None:
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Labelled'):
        super(Labelled, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Labelled, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Labelled'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
        super(Labelled, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Labelled, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('label')
        if value is not None:
            already_processed.append('label')
            self.label = value
        super(Labelled, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Labelled, self).buildChildren(child_, nodeName_, True)
        pass
# end class Labelled


class AbstractObs(Labelled):
    """The AbstractObs type is the superclass for single observations, i.e.
    cells in a matrix. A concrete instance of AbstractObs has a
    "char" attribute that either refers to an explicitly defined
    character (e.g. in categorical matrices) or to a column number,
    and a "state" attribute that either holds a reference to an
    explicitly defined state, or a raw state value (e.g. a
    nucleotide, a continuous value)."""
    subclass = None
    superclass = Labelled
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, char=None, state=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractObs, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.char = _cast(None, char)
        self.state = _cast(None, state)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractObs.subclass:
            return AbstractObs.subclass(*args_, **kwargs_)
        else:
            return AbstractObs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_char(self): return self.char
    def set_char(self, char): self.char = char
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractObs')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractObs"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObs'):
        super(AbstractObs, self).exportAttributes(outfile, level, namespace_, name_='AbstractObs')
        outfile.write(' char=%s' % (quote_attrib(self.char), ))
        outfile.write(' state=%s' % (quote_attrib(self.state), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObs'):
        super(AbstractObs, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractObs, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractObs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.char is not None:
            showIndent(outfile, level)
            outfile.write('char = %s,\n' % (self.char,))
        if self.state is not None:
            showIndent(outfile, level)
            outfile.write('state = %s,\n' % (self.state,))
        super(AbstractObs, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractObs, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('char')
        if value is not None:
            already_processed.append('char')
            self.char = value
        value = attrs.get('state')
        if value is not None:
            already_processed.append('state')
            self.state = value
        super(AbstractObs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractObs, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractObs


class IDTagged(Labelled):
    """The IDTagged complexType is a super class for objects that require
    unique id attributes of type xs:ID. The id must be unique within
    the XML document."""
    subclass = None
    superclass = Labelled
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, valueOf_=None, mixedclass_=None, content_=None):
        super(IDTagged, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IDTagged.subclass:
            return IDTagged.subclass(*args_, **kwargs_)
        else:
            return IDTagged(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='IDTagged', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='IDTagged')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="IDTagged"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='IDTagged'):
        super(IDTagged, self).exportAttributes(outfile, level, namespace_, name_='IDTagged')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='IDTagged'):
        super(IDTagged, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(IDTagged, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='IDTagged'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(IDTagged, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IDTagged, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(IDTagged, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(IDTagged, self).buildChildren(child_, nodeName_, True)
        pass
# end class IDTagged


class Taxa(IDTagged):
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otu=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Taxa, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        if otu is None:
            self.otu = []
        else:
            self.otu = otu
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Taxa.subclass:
            return Taxa.subclass(*args_, **kwargs_)
        else:
            return Taxa(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otu(self): return self.otu
    def set_otu(self, otu): self.otu = otu
    def add_otu(self, value): self.otu.append(value)
    def insert_otu(self, index, value): self.otu[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Taxa', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Taxa')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Taxa"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Taxa'):
        super(Taxa, self).exportAttributes(outfile, level, namespace_, name_='Taxa')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Taxa'):
        super(Taxa, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.otu or
            self.valueOf_ or
            super(Taxa, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Taxa'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(Taxa, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Taxa, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Taxa, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'otu':
            childobj_ = Taxon.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'otu', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_otu'):
              self.add_otu(obj_.value)
            elif hasattr(self, 'set_otu'):
              self.set_otu(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Taxa, self).buildChildren(child_, nodeName_, True)
# end class Taxa


class Taxon(IDTagged):
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Taxon, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Taxon.subclass:
            return Taxon.subclass(*args_, **kwargs_)
        else:
            return Taxon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Taxon', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Taxon')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Taxon"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Taxon'):
        super(Taxon, self).exportAttributes(outfile, level, namespace_, name_='Taxon')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Taxon'):
        super(Taxon, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Taxon, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Taxon'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(Taxon, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Taxon, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Taxon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Taxon, self).buildChildren(child_, nodeName_, True)
        pass
# end class Taxon


class AbstractTrees(IDTagged):
    """The AbstractTrees superclass is what concrete trees inherit from."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, network=None, tree=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractTrees, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        if network is None:
            self.network = []
        else:
            self.network = network
        if tree is None:
            self.tree = []
        else:
            self.tree = tree
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractTrees.subclass:
            return AbstractTrees.subclass(*args_, **kwargs_)
        else:
            return AbstractTrees(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def add_network(self, value): self.network.append(value)
    def insert_network(self, index, value): self.network[index] = value
    def get_tree(self): return self.tree
    def set_tree(self, tree): self.tree = tree
    def add_tree(self, value): self.tree.append(value)
    def insert_tree(self, index, value): self.tree[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractTrees', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractTrees')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractTrees"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractTrees'):
        super(AbstractTrees, self).exportAttributes(outfile, level, namespace_, name_='AbstractTrees')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractTrees'):
        super(AbstractTrees, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.network or
            self.tree or
            self.valueOf_ or
            super(AbstractTrees, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractTrees'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractTrees, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTrees, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractTrees, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'network':
            childobj_ = AbstractNetwork.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'network', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_network'):
              self.add_network(obj_.value)
            elif hasattr(self, 'set_network'):
              self.set_network(obj_.value)
        elif nodeName_ == 'tree':
            childobj_ = AbstractTree.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'tree', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_tree'):
              self.add_tree(obj_.value)
            elif hasattr(self, 'set_tree'):
              self.set_tree(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractTrees, self).buildChildren(child_, nodeName_, True)
# end class AbstractTrees


class AbstractNetwork(IDTagged):
    """The AbstractNetwork superclass is what a concrete network inherits
    from."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, node=None, edge=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractNetwork, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        if node is None:
            self.node = []
        else:
            self.node = node
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractNetwork.subclass:
            return AbstractNetwork.subclass(*args_, **kwargs_)
        else:
            return AbstractNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractNetwork', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractNetwork')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractNetwork"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractNetwork'):
        super(AbstractNetwork, self).exportAttributes(outfile, level, namespace_, name_='AbstractNetwork')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractNetwork'):
        super(AbstractNetwork, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.node or
            self.edge or
            self.valueOf_ or
            super(AbstractNetwork, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractNetwork'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractNetwork, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractNetwork, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'node':
            childobj_ = AbstractNode.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'node', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_node'):
              self.add_node(obj_.value)
            elif hasattr(self, 'set_node'):
              self.set_node(obj_.value)
        elif nodeName_ == 'edge':
            childobj_ = AbstractEdge.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'edge', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_edge'):
              self.add_edge(obj_.value)
            elif hasattr(self, 'set_edge'):
              self.set_edge(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractNetwork, self).buildChildren(child_, nodeName_, True)
# end class AbstractNetwork


class AbstractTree(IDTagged):
    """The AbstractTree superclass is what a concrete tree inherits from."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, node=None, rootedge=None, edge=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractTree, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        if node is None:
            self.node = []
        else:
            self.node = node
        self.rootedge = rootedge
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractTree.subclass:
            return AbstractTree.subclass(*args_, **kwargs_)
        else:
            return AbstractTree(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_rootedge(self): return self.rootedge
    def set_rootedge(self, rootedge): self.rootedge = rootedge
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractTree', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractTree')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractTree"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractTree'):
        super(AbstractTree, self).exportAttributes(outfile, level, namespace_, name_='AbstractTree')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractTree'):
        super(AbstractTree, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.node or
            self.rootedge is not None or
            self.edge or
            self.valueOf_ or
            super(AbstractTree, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractTree'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractTree, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractTree, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractTree, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'node':
            childobj_ = AbstractNode.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'node', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_node'):
              self.add_node(obj_.value)
            elif hasattr(self, 'set_node'):
              self.set_node(obj_.value)
        elif nodeName_ == 'rootedge':
            childobj_ = AbstractRootEdge.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'rootedge', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_rootedge'):
              self.add_rootedge(obj_.value)
            elif hasattr(self, 'set_rootedge'):
              self.set_rootedge(obj_.value)
        elif nodeName_ == 'edge':
            childobj_ = AbstractEdge.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'edge', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_edge'):
              self.add_edge(obj_.value)
            elif hasattr(self, 'set_edge'):
              self.set_edge(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractTree, self).buildChildren(child_, nodeName_, True)
# end class AbstractTree


class AbstractRootEdge(IDTagged):
    """The AbstractRootEdge complex type is a superclass for the edge that
    leads into a root, i.e. an edge with only a target attribute,
    but no source attribute. This type of edge is used for
    coalescent trees, where the initial lineage has a certain length
    before things start splitting up."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, length=None, target=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractRootEdge, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.length = _cast(None, length)
        self.target = _cast(None, target)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractRootEdge.subclass:
            return AbstractRootEdge.subclass(*args_, **kwargs_)
        else:
            return AbstractRootEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractRootEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractRootEdge')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractRootEdge"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractRootEdge'):
        super(AbstractRootEdge, self).exportAttributes(outfile, level, namespace_, name_='AbstractRootEdge')
        if self.length is not None:
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractRootEdge'):
        super(AbstractRootEdge, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractRootEdge, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractRootEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %s,\n' % (self.length,))
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target = "%s",\n' % (self.target,))
        super(AbstractRootEdge, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractRootEdge, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            self.length = value
        value = attrs.get('target')
        if value is not None:
            already_processed.append('target')
            self.target = value
        super(AbstractRootEdge, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractRootEdge, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractRootEdge


class AbstractEdge(IDTagged):
    """The AbstractEdge superclass is what concrete edges inherit from by
    restriction. It represents an edge element much like that of
    GraphML, i.e. an element that connects node elements."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, source=None, length=None, target=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractEdge, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.source = _cast(None, source)
        self.length = _cast(None, length)
        self.target = _cast(None, target)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractEdge.subclass:
            return AbstractEdge.subclass(*args_, **kwargs_)
        else:
            return AbstractEdge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractEdge', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractEdge')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractEdge"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractEdge'):
        super(AbstractEdge, self).exportAttributes(outfile, level, namespace_, name_='AbstractEdge')
        outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding), input_name='source'), ))
        if self.length is not None:
            outfile.write(' length=%s' % (quote_attrib(self.length), ))
        outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractEdge'):
        super(AbstractEdge, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractEdge, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractEdge'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source = "%s",\n' % (self.source,))
        if self.length is not None:
            showIndent(outfile, level)
            outfile.write('length = %s,\n' % (self.length,))
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target = "%s",\n' % (self.target,))
        super(AbstractEdge, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractEdge, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('source')
        if value is not None:
            already_processed.append('source')
            self.source = value
        value = attrs.get('length')
        if value is not None:
            already_processed.append('length')
            self.length = value
        value = attrs.get('target')
        if value is not None:
            already_processed.append('target')
            self.target = value
        super(AbstractEdge, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractEdge, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractEdge


class AbstractChar(IDTagged):
    """The AbstractChar type is the superclass for a column definition,
    which may have a "states" attribute that refers to an
    AbstractStates element, a codon attribute of type CodonPosition
    and an id attribute that may be an actual id (e.g. for
    categorical matrices where observations explicitly refer to a
    column definition) or an integer for sequence matrices."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, tokens=None, states=None, codon=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractChar, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.tokens = _cast(None, tokens)
        self.states = _cast(None, states)
        self.codon = _cast(None, codon)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractChar.subclass:
            return AbstractChar.subclass(*args_, **kwargs_)
        else:
            return AbstractChar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tokens(self): return self.tokens
    def set_tokens(self, tokens): self.tokens = tokens
    def validate_MSTokenLength(self, value):
        # Validate type MSTokenLength, a restriction on xs:positiveInteger.
        pass
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_codon(self): return self.codon
    def set_codon(self, codon): self.codon = codon
    def validate_CodonPosition(self, value):
        # Validate type CodonPosition, a restriction on xs:nonNegativeInteger.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractChar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractChar')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractChar"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractChar'):
        super(AbstractChar, self).exportAttributes(outfile, level, namespace_, name_='AbstractChar')
        if self.tokens is not None:
            outfile.write(' tokens=%s' % (quote_attrib(self.tokens), ))
        if self.states is not None:
            outfile.write(' states=%s' % (self.gds_format_string(quote_attrib(self.states).encode(ExternalEncoding), input_name='states'), ))
        if self.codon is not None:
            outfile.write(' codon=%s' % (quote_attrib(self.codon), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractChar'):
        super(AbstractChar, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractChar, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractChar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tokens is not None:
            showIndent(outfile, level)
            outfile.write('tokens = %d,\n' % (self.tokens,))
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states = "%s",\n' % (self.states,))
        if self.codon is not None:
            showIndent(outfile, level)
            outfile.write('codon = %d,\n' % (self.codon,))
        super(AbstractChar, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractChar, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('tokens')
        if value is not None:
            already_processed.append('tokens')
            self.tokens = value
            self.validate_MSTokenLength(self.tokens)    # validate type MSTokenLength
        value = attrs.get('states')
        if value is not None:
            already_processed.append('states')
            self.states = value
        value = attrs.get('codon')
        if value is not None:
            already_processed.append('codon')
            self.codon = value
            self.validate_CodonPosition(self.codon)    # validate type CodonPosition
        super(AbstractChar, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractChar, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractChar


class AbstractStates(IDTagged):
    """A container for a set of AbstractState elements."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, state=None, polymorphic_state_set=None, uncertain_state_set=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractStates, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        if state is None:
            self.state = []
        else:
            self.state = state
        if polymorphic_state_set is None:
            self.polymorphic_state_set = []
        else:
            self.polymorphic_state_set = polymorphic_state_set
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractStates.subclass:
            return AbstractStates.subclass(*args_, **kwargs_)
        else:
            return AbstractStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def get_polymorphic_state_set(self): return self.polymorphic_state_set
    def set_polymorphic_state_set(self, polymorphic_state_set): self.polymorphic_state_set = polymorphic_state_set
    def add_polymorphic_state_set(self, value): self.polymorphic_state_set.append(value)
    def insert_polymorphic_state_set(self, index, value): self.polymorphic_state_set[index] = value
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractStates', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractStates')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractStates"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractStates'):
        super(AbstractStates, self).exportAttributes(outfile, level, namespace_, name_='AbstractStates')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractStates'):
        super(AbstractStates, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.state or
            self.polymorphic_state_set or
            self.uncertain_state_set or
            self.valueOf_ or
            super(AbstractStates, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractStates'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractStates, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractStates, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractStates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'state':
            childobj_ = AbstractState.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'state', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_state'):
              self.add_state(obj_.value)
            elif hasattr(self, 'set_state'):
              self.set_state(obj_.value)
        elif nodeName_ == 'polymorphic_state_set':
            childobj_ = AbstractPolymorphicStateSet.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'polymorphic_state_set', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_polymorphic_state_set'):
              self.add_polymorphic_state_set(obj_.value)
            elif hasattr(self, 'set_polymorphic_state_set'):
              self.set_polymorphic_state_set(obj_.value)
        elif nodeName_ == 'uncertain_state_set':
            childobj_ = AbstractUncertainStateSet.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'uncertain_state_set', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_uncertain_state_set'):
              self.add_uncertain_state_set(obj_.value)
            elif hasattr(self, 'set_uncertain_state_set'):
              self.set_uncertain_state_set(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractStates, self).buildChildren(child_, nodeName_, True)
# end class AbstractStates


class AbstractState(IDTagged):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, symbol=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractState, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.symbol = _cast(None, symbol)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractState.subclass:
            return AbstractState.subclass(*args_, **kwargs_)
        else:
            return AbstractState(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_symbol(self): return self.symbol
    def set_symbol(self, symbol): self.symbol = symbol
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractState', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractState')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractState"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractState'):
        super(AbstractState, self).exportAttributes(outfile, level, namespace_, name_='AbstractState')
        outfile.write(' symbol=%s' % (quote_attrib(self.symbol), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractState'):
        super(AbstractState, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractState, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractState'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.symbol is not None:
            showIndent(outfile, level)
            outfile.write('symbol = %s,\n' % (self.symbol,))
        super(AbstractState, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractState, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('symbol')
        if value is not None:
            already_processed.append('symbol')
            self.symbol = value
        super(AbstractState, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractState, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractState


class Class(IDTagged):
    """Elements of the Class complexType are elements with an ID to which
    other elements refer using the "class" attribute. The purpose of
    this to allow creation of sets, but rather than having a set
    specify its members (such as character sets in nexus), in nexml
    the members specify which class(es) they belong to. This is more
    idiomatic for xml, consider for example the "class" attribute in
    (X)HTML which works the same way, and is used for example for
    cascading style sheets."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Class, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Class.subclass:
            return Class.subclass(*args_, **kwargs_)
        else:
            return Class(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Class', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Class')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Class"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Class'):
        super(Class, self).exportAttributes(outfile, level, namespace_, name_='Class')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Class'):
        super(Class, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Class, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Class'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(Class, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Class, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Class, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Class, self).buildChildren(child_, nodeName_, True)
        pass
# end class Class


class TaxaLinked(IDTagged):
    """The TaxaLinked complexType is a super class for objects that that
    require an otus id reference."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otus=None, valueOf_=None, mixedclass_=None, content_=None):
        super(TaxaLinked, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.otus = _cast(None, otus)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TaxaLinked.subclass:
            return TaxaLinked.subclass(*args_, **kwargs_)
        else:
            return TaxaLinked(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otus(self): return self.otus
    def set_otus(self, otus): self.otus = otus
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TaxaLinked', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TaxaLinked')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="TaxaLinked"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TaxaLinked'):
        super(TaxaLinked, self).exportAttributes(outfile, level, namespace_, name_='TaxaLinked')
        outfile.write(' otus=%s' % (self.gds_format_string(quote_attrib(self.otus).encode(ExternalEncoding), input_name='otus'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TaxaLinked'):
        super(TaxaLinked, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TaxaLinked, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TaxaLinked'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.otus is not None:
            showIndent(outfile, level)
            outfile.write('otus = "%s",\n' % (self.otus,))
        super(TaxaLinked, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaxaLinked, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('otus')
        if value is not None:
            already_processed.append('otus')
            self.otus = value
        super(TaxaLinked, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TaxaLinked, self).buildChildren(child_, nodeName_, True)
        pass
# end class TaxaLinked


class OptionalTaxonLinked(IDTagged):
    """The OptionalOTULinked complexType is a super class for objects that
    that optionally have an otu id reference."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otu=None, valueOf_=None, mixedclass_=None, content_=None):
        super(OptionalTaxonLinked, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.otu = _cast(None, otu)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OptionalTaxonLinked.subclass:
            return OptionalTaxonLinked.subclass(*args_, **kwargs_)
        else:
            return OptionalTaxonLinked(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otu(self): return self.otu
    def set_otu(self, otu): self.otu = otu
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='OptionalTaxonLinked', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='OptionalTaxonLinked')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="OptionalTaxonLinked"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='OptionalTaxonLinked'):
        super(OptionalTaxonLinked, self).exportAttributes(outfile, level, namespace_, name_='OptionalTaxonLinked')
        if self.otu is not None:
            outfile.write(' otu=%s' % (self.gds_format_string(quote_attrib(self.otu).encode(ExternalEncoding), input_name='otu'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='OptionalTaxonLinked'):
        super(OptionalTaxonLinked, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(OptionalTaxonLinked, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='OptionalTaxonLinked'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.otu is not None:
            showIndent(outfile, level)
            outfile.write('otu = "%s",\n' % (self.otu,))
        super(OptionalTaxonLinked, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OptionalTaxonLinked, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('otu')
        if value is not None:
            already_processed.append('otu')
            self.otu = value
        super(OptionalTaxonLinked, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(OptionalTaxonLinked, self).buildChildren(child_, nodeName_, True)
        pass
# end class OptionalTaxonLinked


class TaxonLinked(IDTagged):
    """The TaxonLinked complexType is a super class for objects that
    require a taxon id reference."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otu=None, valueOf_=None, mixedclass_=None, content_=None):
        super(TaxonLinked, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        self.otu = _cast(None, otu)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TaxonLinked.subclass:
            return TaxonLinked.subclass(*args_, **kwargs_)
        else:
            return TaxonLinked(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otu(self): return self.otu
    def set_otu(self, otu): self.otu = otu
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='TaxonLinked', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TaxonLinked')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="TaxonLinked"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='TaxonLinked'):
        super(TaxonLinked, self).exportAttributes(outfile, level, namespace_, name_='TaxonLinked')
        outfile.write(' otu=%s' % (self.gds_format_string(quote_attrib(self.otu).encode(ExternalEncoding), input_name='otu'), ))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='TaxonLinked'):
        super(TaxonLinked, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(TaxonLinked, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='TaxonLinked'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.otu is not None:
            showIndent(outfile, level)
            outfile.write('otu = "%s",\n' % (self.otu,))
        super(TaxonLinked, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaxonLinked, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('otu')
        if value is not None:
            already_processed.append('otu')
            self.otu = value
        super(TaxonLinked, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(TaxonLinked, self).buildChildren(child_, nodeName_, True)
        pass
# end class TaxonLinked


class Segmented(IDTagged):
    """The Segmented complexType is for elements that contain multiple
    child elements of the same type, e.g. multiple cells in a row,
    multiple nodes in a tree, etc. Segmented elements can hold one
    or more elements of type Class, such that the segments can refer
    to the ID of the class they belong to."""
    subclass = None
    superclass = IDTagged
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Segmented, self).__init__(classxx, id, about, meta, label, valueOf_, mixedclass_, content_, )
        if classxx is None:
            self.classxx = []
        else:
            self.classxx = classxx
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Segmented.subclass:
            return Segmented.subclass(*args_, **kwargs_)
        else:
            return Segmented(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def add_class(self, value): self.classxx.append(value)
    def insert_class(self, index, value): self.classxx[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Segmented', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Segmented')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Segmented"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Segmented'):
        super(Segmented, self).exportAttributes(outfile, level, namespace_, name_='Segmented')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Segmented'):
        super(Segmented, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.classxx or
            self.valueOf_ or
            super(Segmented, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Segmented'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(Segmented, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Segmented, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Segmented, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'class':
            childobj_ = Class.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'class', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_class'):
              self.add_class(obj_.value)
            elif hasattr(self, 'set_class'):
              self.set_class(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Segmented, self).buildChildren(child_, nodeName_, True)
# end class Segmented


class AbstractNode(OptionalTaxonLinked):
    """The AbstractNode superclass is what concrete nodes inherit from by
    restriction. It represents a node element much like that of
    GraphML, i.e. an element that is connected into a tree by edge
    elements."""
    subclass = None
    superclass = OptionalTaxonLinked
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otu=None, root=False, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractNode, self).__init__(classxx, id, about, meta, label, otu, valueOf_, mixedclass_, content_, )
        self.root = _cast(bool, root)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractNode.subclass:
            return AbstractNode.subclass(*args_, **kwargs_)
        else:
            return AbstractNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_root(self): return self.root
    def set_root(self, root): self.root = root
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractNode', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractNode')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractNode"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractNode'):
        super(AbstractNode, self).exportAttributes(outfile, level, namespace_, name_='AbstractNode')
        if self.root is not None:
            outfile.write(' root="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.root)), input_name='root'))
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractNode'):
        super(AbstractNode, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AbstractNode, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractNode'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.root is not None:
            showIndent(outfile, level)
            outfile.write('root = %s,\n' % (self.root,))
        super(AbstractNode, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractNode, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('root')
        if value is not None:
            already_processed.append('root')
            if value in ('true', '1'):
                self.root = True
            elif value in ('false', '0'):
                self.root = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(AbstractNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractNode, self).buildChildren(child_, nodeName_, True)
        pass
# end class AbstractNode


class Trees(TaxaLinked):
    """A concrete container for tree objects."""
    subclass = None
    superclass = TaxaLinked
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otus=None, network=None, tree=None, valueOf_=None, mixedclass_=None, content_=None):
        super(Trees, self).__init__(classxx, id, about, meta, label, otus, valueOf_, mixedclass_, content_, )
        if network is None:
            self.network = []
        else:
            self.network = network
        if tree is None:
            self.tree = []
        else:
            self.tree = tree
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if Trees.subclass:
            return Trees.subclass(*args_, **kwargs_)
        else:
            return Trees(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def add_network(self, value): self.network.append(value)
    def insert_network(self, index, value): self.network[index] = value
    def get_tree(self): return self.tree
    def set_tree(self, tree): self.tree = tree
    def add_tree(self, value): self.tree.append(value)
    def insert_tree(self, index, value): self.tree[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='Trees', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='Trees')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="Trees"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='Trees'):
        super(Trees, self).exportAttributes(outfile, level, namespace_, name_='Trees')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='Trees'):
        super(Trees, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.network or
            self.tree or
            self.valueOf_ or
            super(Trees, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='Trees'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(Trees, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Trees, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Trees, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'network':
            childobj_ = AbstractNetwork.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'network', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_network'):
              self.add_network(obj_.value)
            elif hasattr(self, 'set_network'):
              self.set_network(obj_.value)
        elif nodeName_ == 'tree':
            childobj_ = AbstractTree.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'tree', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_tree'):
              self.add_tree(obj_.value)
            elif hasattr(self, 'set_tree'):
              self.set_tree(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(Trees, self).buildChildren(child_, nodeName_, True)
# end class Trees


class AbstractBlock(TaxaLinked):
    """The AbstractBlock is the superclass for blocks that contain an
    element structure of type AbstractFormat."""
    subclass = None
    superclass = TaxaLinked
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otus=None, format=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractBlock, self).__init__(classxx, id, about, meta, label, otus, valueOf_, mixedclass_, content_, )
        self.format = format
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractBlock.subclass:
            return AbstractBlock.subclass(*args_, **kwargs_)
        else:
            return AbstractBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractBlock', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractBlock')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractBlock"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractBlock'):
        super(AbstractBlock, self).exportAttributes(outfile, level, namespace_, name_='AbstractBlock')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractBlock'):
        super(AbstractBlock, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.format is not None or
            self.valueOf_ or
            super(AbstractBlock, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractBlock'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractBlock, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractBlock, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractBlock, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'format':
            childobj_ = AbstractFormat.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'format', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_format'):
              self.add_format(obj_.value)
            elif hasattr(self, 'set_format'):
              self.set_format(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractBlock, self).buildChildren(child_, nodeName_, True)
# end class AbstractBlock


class AbstractObsRow(TaxonLinked):
    """The AbstractObsRow represents a single row in a matrix. The row must
    refer to a previously declared taxon element by its id attribute
    (and must have an id itself, may have a label, and may have
    dictionary attachments). The row contains multiple obs elements."""
    subclass = None
    superclass = TaxonLinked
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otu=None, cell=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractObsRow, self).__init__(classxx, id, about, meta, label, otu, valueOf_, mixedclass_, content_, )
        if cell is None:
            self.cell = []
        else:
            self.cell = cell
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractObsRow.subclass:
            return AbstractObsRow.subclass(*args_, **kwargs_)
        else:
            return AbstractObsRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cell(self): return self.cell
    def set_cell(self, cell): self.cell = cell
    def add_cell(self, value): self.cell.append(value)
    def insert_cell(self, index, value): self.cell[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObsRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractObsRow')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractObsRow"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObsRow'):
        super(AbstractObsRow, self).exportAttributes(outfile, level, namespace_, name_='AbstractObsRow')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractObsRow'):
        super(AbstractObsRow, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.cell or
            self.valueOf_ or
            super(AbstractObsRow, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractObsRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractObsRow, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractObsRow, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractObsRow, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'cell':
            childobj_ = AbstractObs.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'cell', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_cell'):
              self.add_cell(obj_.value)
            elif hasattr(self, 'set_cell'):
              self.set_cell(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractObsRow, self).buildChildren(child_, nodeName_, True)
# end class AbstractObsRow


class AbstractSeqRow(TaxonLinked):
    """The AbstractSeqRow represents a single row in a matrix. The row must
    refer to a previously declared taxon element by its id attribute
    (and must have an id itself, may have a label, and may have
    dictionary attachments). The row contains a single seq element
    with raw character data."""
    subclass = None
    superclass = TaxonLinked
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otu=None, seq=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractSeqRow, self).__init__(classxx, id, about, meta, label, otu, valueOf_, mixedclass_, content_, )
        self.seq = seq
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractSeqRow.subclass:
            return AbstractSeqRow.subclass(*args_, **kwargs_)
        else:
            return AbstractSeqRow(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_seq(self): return self.seq
    def set_seq(self, seq): self.seq = seq
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqRow', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractSeqRow')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractSeqRow"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqRow'):
        super(AbstractSeqRow, self).exportAttributes(outfile, level, namespace_, name_='AbstractSeqRow')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqRow'):
        super(AbstractSeqRow, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.seq is not None or
            self.valueOf_ or
            super(AbstractSeqRow, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractSeqRow'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractSeqRow, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractSeqRow, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractSeqRow, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'seq' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'seq', valuestr_)
            self.content_.append(obj_)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractSeqRow, self).buildChildren(child_, nodeName_, True)
# end class AbstractSeqRow


class AbstractUncertainStateSet(AbstractState):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = AbstractState
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, symbol=None, member=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractUncertainStateSet, self).__init__(classxx, id, about, meta, label, symbol, valueOf_, mixedclass_, content_, )
        if member is None:
            self.member = []
        else:
            self.member = member
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractUncertainStateSet.subclass:
            return AbstractUncertainStateSet.subclass(*args_, **kwargs_)
        else:
            return AbstractUncertainStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_member(self): return self.member
    def set_member(self, member): self.member = member
    def add_member(self, value): self.member.append(value)
    def insert_member(self, index, value): self.member[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractUncertainStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractUncertainStateSet')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractUncertainStateSet"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractUncertainStateSet'):
        super(AbstractUncertainStateSet, self).exportAttributes(outfile, level, namespace_, name_='AbstractUncertainStateSet')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractUncertainStateSet'):
        super(AbstractUncertainStateSet, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.member or
            self.valueOf_ or
            super(AbstractUncertainStateSet, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractUncertainStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractUncertainStateSet, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractUncertainStateSet, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractUncertainStateSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'member':
            childobj_ = AbstractMapping.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'member', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_member'):
              self.add_member(obj_.value)
            elif hasattr(self, 'set_member'):
              self.set_member(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractUncertainStateSet, self).buildChildren(child_, nodeName_, True)
# end class AbstractUncertainStateSet


class AbstractCells(AbstractBlock):
    """The AbstractSeqBlock type is the superclass for character blocks
    that consist of granular character state observations."""
    subclass = None
    superclass = AbstractBlock
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otus=None, format=None, matrix=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractCells, self).__init__(classxx, id, about, meta, label, otus, format, valueOf_, mixedclass_, content_, )
        self.matrix = matrix
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractCells.subclass:
            return AbstractCells.subclass(*args_, **kwargs_)
        else:
            return AbstractCells(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractCells', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractCells')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractCells"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractCells'):
        super(AbstractCells, self).exportAttributes(outfile, level, namespace_, name_='AbstractCells')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractCells'):
        super(AbstractCells, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.matrix is not None or
            self.valueOf_ or
            super(AbstractCells, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractCells'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractCells, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractCells, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractCells, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'matrix':
            childobj_ = AbstractObsMatrix.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'matrix', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_matrix'):
              self.add_matrix(obj_.value)
            elif hasattr(self, 'set_matrix'):
              self.set_matrix(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractCells, self).buildChildren(child_, nodeName_, True)
# end class AbstractCells


class AbstractSeqs(AbstractBlock):
    """The AbstractSeqBlock type is the superclass for character blocks
    that consist of raw character sequences."""
    subclass = None
    superclass = AbstractBlock
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, otus=None, format=None, matrix=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractSeqs, self).__init__(classxx, id, about, meta, label, otus, format, valueOf_, mixedclass_, content_, )
        self.matrix = matrix
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractSeqs.subclass:
            return AbstractSeqs.subclass(*args_, **kwargs_)
        else:
            return AbstractSeqs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractSeqs')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractSeqs"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqs'):
        super(AbstractSeqs, self).exportAttributes(outfile, level, namespace_, name_='AbstractSeqs')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractSeqs'):
        super(AbstractSeqs, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.matrix is not None or
            self.valueOf_ or
            super(AbstractSeqs, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractSeqs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractSeqs, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractSeqs, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractSeqs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'matrix':
            childobj_ = AbstractSeqMatrix.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'matrix', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_matrix'):
              self.add_matrix(obj_.value)
            elif hasattr(self, 'set_matrix'):
              self.set_matrix(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractSeqs, self).buildChildren(child_, nodeName_, True)
# end class AbstractSeqs


class AbstractPolymorphicStateSet(AbstractUncertainStateSet):
    """The AbstractState type is the superclass for a state definition. The
    element encloses a required AbstractSymbol element that in
    restricted concrete subclasses must be of a sensible type such
    as a single IUPAC character. It may enclose zero or more
    AbstractMapping elements to resolve ambiguities."""
    subclass = None
    superclass = AbstractUncertainStateSet
    def __init__(self, classxx=None, id=None, about=None, meta=None, label=None, symbol=None, member=None, uncertain_state_set=None, valueOf_=None, mixedclass_=None, content_=None):
        super(AbstractPolymorphicStateSet, self).__init__(classxx, id, about, meta, label, symbol, member, valueOf_, mixedclass_, content_, )
        if uncertain_state_set is None:
            self.uncertain_state_set = []
        else:
            self.uncertain_state_set = uncertain_state_set
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AbstractPolymorphicStateSet.subclass:
            return AbstractPolymorphicStateSet.subclass(*args_, **kwargs_)
        else:
            return AbstractPolymorphicStateSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uncertain_state_set(self): return self.uncertain_state_set
    def set_uncertain_state_set(self, uncertain_state_set): self.uncertain_state_set = uncertain_state_set
    def add_uncertain_state_set(self, value): self.uncertain_state_set.append(value)
    def insert_uncertain_state_set(self, index, value): self.uncertain_state_set[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractPolymorphicStateSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AbstractPolymorphicStateSet')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="AbstractPolymorphicStateSet"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractPolymorphicStateSet'):
        super(AbstractPolymorphicStateSet, self).exportAttributes(outfile, level, namespace_, name_='AbstractPolymorphicStateSet')
    def exportChildren(self, outfile=sys.stdout, level=0, namespace_='', name_='AbstractPolymorphicStateSet'):
        super(AbstractPolymorphicStateSet, self).exportChildren(outfile, level, namespace_, name_)
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.uncertain_state_set or
            self.valueOf_ or
            super(AbstractPolymorphicStateSet, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile=sys.stdout, level=0, name_='AbstractPolymorphicStateSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(AbstractPolymorphicStateSet, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractPolymorphicStateSet, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractPolymorphicStateSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'uncertain_state_set':
            childobj_ = AbstractUncertainStateSet.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'uncertain_state_set', childobj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_uncertain_state_set'):
              self.add_uncertain_state_set(obj_.value)
            elif hasattr(self, 'set_uncertain_state_set'):
              self.set_uncertain_state_set(obj_.value)
        if not from_subclass and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(AbstractPolymorphicStateSet, self).buildChildren(child_, nodeName_, True)
# end class AbstractPolymorphicStateSet


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nexml'
        rootClass = Nexml
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nexml'
        rootClass = Nexml
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Nexml",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nexml'
        rootClass = Nexml
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from last_nexml import *\n\n')
    sys.stdout.write('import last_nexml as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

